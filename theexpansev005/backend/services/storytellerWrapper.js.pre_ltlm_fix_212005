import { chainPhrases } from './phraseChainer.js';

function mapIntentToStoryPlan(intentResult, emotionalSignal) {
  const baseType = intentResult?.type || 'WHAT';

  if (baseType === 'WHAT' || baseType === 'HOW') {
    return { outcomeIntent: 'clarity', strategy: 'info' };
  }

  if (baseType === 'WHEN') {
    return { outcomeIntent: 'clarity', strategy: 'info' };
  }

  if (baseType === 'WHY') {
    return { outcomeIntent: 'exploration', strategy: 'question' };
  }

  if (baseType === 'SEARCH') {
    return { outcomeIntent: 'clarity', strategy: 'info' };
  }

  if (emotionalSignal === 'anxious') {
    return { outcomeIntent: 'reassurance', strategy: 'affirmation' };
  }

  if (emotionalSignal === 'frustrated') {
    return { outcomeIntent: 'validation', strategy: 'reflection' };
  }

  return { outcomeIntent: 'clarity', strategy: 'info' };
}

export async function buildStorytellerResponse({
  intentResult,
  emotionalSignal,
  knowledgeText,
  tone = 'neutral',
  formality = 'casual',
}) {
  if (!knowledgeText) {
    return {
      output: '',
      storytellerMeta: {
        usedStoryteller: false,
        reason: 'no_knowledge_text',
      },
    };
  }

  const { outcomeIntent, strategy } = mapIntentToStoryPlan(
    intentResult,
    emotionalSignal
  );

  try {
    const chainResult = await chainPhrases(outcomeIntent, strategy, {
      tone,
      formality,
      connectorCount: 1,
    });

    const wrapperText = chainResult?.chain?.text || '';

    const output = wrapperText
      ? `${wrapperText} ${knowledgeText}`
      : knowledgeText;

    return {
      output,
      storytellerMeta: {
        usedStoryteller: true,
        outcomeIntent,
        strategy,
        tone,
        formality,
        phraseIds: chainResult?.metadata?.phraseIds || {},
        structureCode: chainResult?.chain?.structureCode || null,
        perRoleCounts: chainResult?.metadata?.phraseCount || null,
      },
    };
  } catch (err) {
    console.warn(`[Storyteller] chainPhrases failed: ${err.message}. Returning unwrapped knowledge.`);
    
    return {
      output: knowledgeText,
      storytellerMeta: {
        usedStoryteller: false,
        reason: 'chainPhrases_error',
        error: err.message,
        outcomeIntent,
        strategy,
        tone,
        formality,
      },
    };
  }
}
