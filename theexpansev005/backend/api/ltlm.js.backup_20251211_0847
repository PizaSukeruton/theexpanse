import express from "express";
import pool from "../db/pool.js";
import generateHexId from "../utils/hexIdGenerator.js";

const router = express.Router();

/**
 * GET /api/ltlm/training?character_id=#700002
 * Returns all LTLM training rows for a specific character.
 */
router.get("/training", async (req, res) => {
    const { character_id } = req.query;

    if (!character_id) {
        return res.status(400).json({ success: false, message: "Missing character_id" });
    }

    try {
        const result = await pool.query(
            `SELECT
                training_example_id,
                speaker_character_id,
                utterance_text,
                dialogue_function_code,
                speech_act_code,
                narrative_function_code,
                pad_pleasure,
                pad_arousal,
                pad_dominance,
                source,
                is_canonical,
                difficulty,
                tags,
                notes,
                created_by,
                created_at
             FROM ltlm_training_examples
             WHERE speaker_character_id = $1
             ORDER BY created_at DESC`,
            [character_id]
        );

        return res.json({ success: true, rows: result.rows });
    } catch (e) {
        console.error("LTLM GET error:", e);
        return res.status(500).json({ success: false, message: "LTLM module error" });
    }
});

/**
 * POST /api/ltlm/training
 * Unified handler for single + batch LTLM insertion
 */
router.post("/training", async (req, res) => {
    const { mode } = req.body;

    if (!mode || !["single", "batch"].includes(mode)) {
        return res.status(400).json({ success: false, message: "Invalid or missing mode" });
    }

    const client = await pool.connect();
    let inserted = 0;

    try {
        await client.query("BEGIN");

        //
        // SINGLE MODE
        //
        if (mode === "single") {
            const {
                speaker_character_id,
                utterance_text,
                dialogue_function_code,
                speech_act_code,
                narrative_function_code,
                pad,
                source,
                is_canonical = true,
                difficulty = 1,
                tags = [],
                notes = "",
                outcome_intent_codes = [],
                created_by = "cms_ltlm"
            } = req.body;

            if (!speaker_character_id || !utterance_text) {
                await client.query("ROLLBACK");
                return res.status(400).json({
                    success: false,
                    message: "Missing required fields for single mode"
                });
            }

            const trainingId = await generateHexId("ltlm_training_example_id");

            await client.query(`
                INSERT INTO ltlm_training_examples (
                    training_example_id,
                    speaker_character_id,
                    utterance_text,
                    dialogue_function_code,
                    speech_act_code,
                    narrative_function_code,
                    pad_pleasure,
                    pad_arousal,
                    pad_dominance,
                    emotion_register_id,
                    source,
                    is_canonical,
                    difficulty,
                    tags,
                    category_confidence,
                    notes,
                    created_by
                ) VALUES (
                    $1, $2, $3,
                    $4, $5, $6,
                    $7, $8, $9,
                    NULL,
                    $10, $11, $12,
                    $13, 1.0, $14, $15
                )
            `, [
                trainingId,
                speaker_character_id,
                utterance_text,
                dialogue_function_code,
                speech_act_code,
                narrative_function_code || null,
                pad.p,
                pad.a,
                pad.d,
                source,
                is_canonical,
                difficulty,
                tags,
                notes,
                created_by
            ]);

            for (const code of outcome_intent_codes || []) {
                const outcomeId = await generateHexId("ltlm_outcome_intent_id");

                await client.query(`
                    INSERT INTO ltlm_training_outcome_intents (
                        ltlm_outcome_intent_id,
                        training_example_id,
                        outcome_intent_code
                    ) VALUES ($1, $2, $3)
                `, [
                    outcomeId,
                    trainingId,
                    code
                ]);
            }

            inserted = 1;
        }

        //
        // BATCH MODE
        //
        if (mode === "batch") {
            const { speaker_character_id, lines, created_by = "cms_ltlm" } = req.body;

            for (const raw of lines) {
                const line = raw.trim();
                if (!line) continue;

                const [
                    utterance,
                    dialogue,
                    speech,
                    narrative,
                    intents,
                    padP,
                    padA,
                    padD
                ] = line.split("|").map(x => x.trim());

                const trainingId = await generateHexId("ltlm_training_example_id");

                await client.query(`
                    INSERT INTO ltlm_training_examples (
                        training_example_id,
                        speaker_character_id,
                        utterance_text,
                        dialogue_function_code,
                        speech_act_code,
                        narrative_function_code,
                        pad_pleasure,
                        pad_arousal,
                        pad_dominance,
                        emotion_register_id,
                        source,
                        is_canonical,
                        difficulty,
                        tags,
                        category_confidence,
                        notes,
                        created_by
                    ) VALUES (
                        $1, $2, $3,
                        $4, $5, $6,
                        $7, $8, $9,
                        NULL,
                        'cms_ltlm',
                        true,
                        1,
                        '{}',
                        1.0,
                        '',
                        $10
                    )
                `, [
                    trainingId,
                    speaker_character_id,
                    utterance,
                    dialogue,
                    speech,
                    narrative === "NULL" ? null : narrative,
                    parseFloat(padP),
                    parseFloat(padA),
                    parseFloat(padD),
                    created_by
                ]);

                if (intents) {
                    for (const code of intents.split(",").map(x => x.trim())) {
                        const intentId = await generateHexId("ltlm_outcome_intent_id");

                        await client.query(`
                            INSERT INTO ltlm_training_outcome_intents (
                                ltlm_outcome_intent_id,
                                training_example_id,
                                outcome_intent_code
                            ) VALUES ($1, $2, $3)
                        `, [
                            intentId,
                            trainingId,
                            code
                        ]);
                    }
                }

                inserted++;
            }
        }

        await client.query("COMMIT");
        return res.json({ success: true, inserted });

    } catch (e) {
        await client.query("ROLLBACK");
        console.error("LTLM POST error:", e);
        return res.status(500).json({ success: false, message: "Insert failed" });
    } finally {
        client.release();
    }
});

export default router;
