import express from "express";
import pool from "../db/pool.js";
import generateHexId from "../utils/hexIdGenerator.js";

const router = express.Router();

/**
 * Helper: Validate PAD values are within [-1.0, +1.0] range
 */
function validatePADRange(pleasure, arousal, dominance) {
    const errors = [];
    
    if (pleasure !== null && pleasure !== undefined) {
        const p = parseFloat(pleasure);
        if (isNaN(p) || p < -1.0 || p > 1.0) {
            errors.push({
                field: "pad_pleasure",
                value: pleasure,
                reason: "Must be numeric between -1.0 and +1.0"
            });
        }
    }
    
    if (arousal !== null && arousal !== undefined) {
        const a = parseFloat(arousal);
        if (isNaN(a) || a < -1.0 || a > 1.0) {
            errors.push({
                field: "pad_arousal",
                value: arousal,
                reason: "Must be numeric between -1.0 and +1.0"
            });
        }
    }
    
    if (dominance !== null && dominance !== undefined) {
        const d = parseFloat(dominance);
        if (isNaN(d) || d < -1.0 || d > 1.0) {
            errors.push({
                field: "pad_dominance",
                value: dominance,
                reason: "Must be numeric between -1.0 and +1.0"
            });
        }
    }
    
    return errors;
}

/**
 * GET /api/ltlm/training?character_id=#700002
 * Returns all LTLM training rows for a specific character.
 */
router.get("/training", async (req, res) => {
    const { character_id } = req.query;

    if (!character_id) {
        return res.status(400).json({ success: false, message: "Missing character_id" });
    }

    try {
        const result = await pool.query(
            `SELECT
                training_example_id,
                speaker_character_id,
                utterance_text,
                dialogue_function_code,
                speech_act_code,
                narrative_function_code,
                pad_pleasure,
                pad_arousal,
                pad_dominance,
                source,
                is_canonical,
                difficulty,
                tags,
                notes,
                created_by,
                created_at
            FROM ltlm_training_examples
            WHERE speaker_character_id = $1
            ORDER BY created_at DESC`,
            [character_id]
        );

        return res.json({ success: true, rows: result.rows });
    } catch (e) {
        console.error("LTLM GET error:", e);
        return res.status(500).json({ success: false, message: "LTLM module error" });
    }
});

/**
 * POST /api/ltlm/training
 * Unified handler for single + batch LTLM insertion with validation
 */
router.post("/training", async (req, res) => {
    const { mode } = req.body;

    if (!mode || !["single", "batch"].includes(mode)) {
        return res.status(400).json({ success: false, message: "Invalid or missing mode" });
    }

    const client = await pool.connect();
    let inserted = 0;

    try {
        await client.query("BEGIN");

        //
        // SINGLE MODE
        //
        if (mode === "single") {
            const {
                speaker_character_id,
                utterance_text,
                dialogue_function_code,
                speech_act_code,
                narrative_function_code,
                pad,
                source,
                is_canonical = true,
                difficulty = 1,
                tags = [],
                notes = "",
                outcome_intent_codes = [],
                created_by = "cms_ltlm"
            } = req.body;

            if (!speaker_character_id || !utterance_text) {
                await client.query("ROLLBACK");
                return res.status(400).json({
                    success: false,
                    message: "Missing required fields for single mode"
                });
            }

            // Validate PAD range
            const padErrors = validatePADRange(pad?.p, pad?.a, pad?.d);
            if (padErrors.length > 0) {
                await client.query("ROLLBACK");
                return res.status(400).json({
                    success: false,
                    message: "Invalid PAD values",
                    errors: padErrors
                });
            }

            // Validate dialogue_function_code exists
            if (dialogue_function_code) {
                const dialogueCheck = await client.query(
                    "SELECT 1 FROM dialogue_function_categories WHERE category_code = $1 AND is_active = true",
                    [dialogue_function_code]
                );
                if (dialogueCheck.rows.length === 0) {
                    await client.query("ROLLBACK");
                    return res.status(400).json({
                        success: false,
                        message: "Invalid category code",
                        errors: [{
                            field: "dialogue_function_code",
                            value: dialogue_function_code,
                            reason: "Code not found in dialogue_function_categories"
                        }]
                    });
                }
            }

            // Validate speech_act_code exists
            if (speech_act_code) {
                const speechCheck = await client.query(
                    "SELECT 1 FROM speech_act_categories WHERE category_code = $1 AND is_active = true",
                    [speech_act_code]
                );
                if (speechCheck.rows.length === 0) {
                    await client.query("ROLLBACK");
                    return res.status(400).json({
                        success: false,
                        message: "Invalid category code",
                        errors: [{
                            field: "speech_act_code",
                            value: speech_act_code,
                            reason: "Code not found in speech_act_categories"
                        }]
                    });
                }
            }

            // Validate narrative_function_code if provided
            if (narrative_function_code && narrative_function_code !== "NULL") {
                const narrativeCheck = await client.query(
                    "SELECT 1 FROM narrative_function_categories WHERE category_code = $1 AND is_active = true",
                    [narrative_function_code]
                );
                if (narrativeCheck.rows.length === 0) {
                    await client.query("ROLLBACK");
                    return res.status(400).json({
                        success: false,
                        message: "Invalid category code",
                        errors: [{
                            field: "narrative_function_code",
                            value: narrative_function_code,
                            reason: "Code not found in narrative_function_categories"
                        }]
                    });
                }
            }

            // Validate outcome intent codes if provided
            if (outcome_intent_codes && outcome_intent_codes.length > 0) {
                const invalidIntents = [];
                for (const code of outcome_intent_codes) {
                    const intentCheck = await client.query(
                        "SELECT 1 FROM outcome_intent_categories WHERE category_code = $1 AND is_active = true",
                        [code]
                    );
                    if (intentCheck.rows.length === 0) {
                        invalidIntents.push(code);
                    }
                }
                if (invalidIntents.length > 0) {
                    await client.query("ROLLBACK");
                    return res.status(400).json({
                        success: false,
                        message: "Invalid outcome intent codes",
                        errors: invalidIntents.map(code => ({
                            field: "outcome_intent_code",
                            value: code,
                            reason: "Code not found in outcome_intent_categories"
                        }))
                    });
                }
            }

            // All validations passed, proceed with insert
            const trainingId = await generateHexId("ltlm_training_example_id");

            await client.query(`
                INSERT INTO ltlm_training_examples (
                    training_example_id,
                    speaker_character_id,
                    utterance_text,
                    dialogue_function_code,
                    speech_act_code,
                    narrative_function_code,
                    pad_pleasure,
                    pad_arousal,
                    pad_dominance,
                    emotion_register_id,
                    source,
                    is_canonical,
                    difficulty,
                    tags,
                    category_confidence,
                    notes,
                    created_by
                ) VALUES (
                    $1, $2, $3,
                    $4, $5, $6,
                    $7, $8, $9,
                    NULL,
                    $10, $11, $12,
                    $13, 1.0, $14, $15
                )
            `, [
                trainingId,
                speaker_character_id,
                utterance_text,
                dialogue_function_code,
                speech_act_code,
                narrative_function_code || null,
                parseFloat(pad.p),
                parseFloat(pad.a),
                parseFloat(pad.d),
                source,
                is_canonical,
                difficulty,
                tags,
                notes,
                created_by
            ]);

            for (const code of outcome_intent_codes || []) {
                const outcomeId = await generateHexId("ltlm_outcome_intent_id");

                await client.query(`
                    INSERT INTO ltlm_training_outcome_intents (
                        ltlm_outcome_intent_id,
                        training_example_id,
                        outcome_intent_code
                    ) VALUES ($1, $2, $3)
                `, [
                    outcomeId,
                    trainingId,
                    code
                ]);
            }

            inserted = 1;
        }

        //
        // BATCH MODE
        //
        if (mode === "batch") {
            const { speaker_character_id, lines, created_by = "cms_ltlm" } = req.body;

            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const raw = lines[lineIndex];
                const line = raw.trim();
                if (!line) continue;

                const [
                    utterance,
                    dialogue,
                    speech,
                    narrative,
                    intents,
                    padP,
                    padA,
                    padD
                ] = line.split("|").map(x => x.trim());

                // Validate PAD range for this line
                const padErrors = validatePADRange(padP, padA, padD);
                if (padErrors.length > 0) {
                    await client.query("ROLLBACK");
                    return res.status(400).json({
                        success: false,
                        message: "Invalid PAD values in batch",
                        errors: padErrors.map(err => ({
                            ...err,
                            line: lineIndex + 1
                        }))
                    });
                }

                // Validate dialogue_function_code
                if (dialogue && dialogue !== "NULL") {
                    const dialogueCheck = await client.query(
                        "SELECT 1 FROM dialogue_function_categories WHERE category_code = $1 AND is_active = true",
                        [dialogue]
                    );
                    if (dialogueCheck.rows.length === 0) {
                        await client.query("ROLLBACK");
                        return res.status(400).json({
                            success: false,
                            message: "Invalid category code in batch",
                            errors: [{
                                line: lineIndex + 1,
                                field: "dialogue_function_code",
                                value: dialogue,
                                reason: "Code not found in dialogue_function_categories"
                            }]
                        });
                    }
                }

                // Validate speech_act_code
                if (speech && speech !== "NULL") {
                    const speechCheck = await client.query(
                        "SELECT 1 FROM speech_act_categories WHERE category_code = $1 AND is_active = true",
                        [speech]
                    );
                    if (speechCheck.rows.length === 0) {
                        await client.query("ROLLBACK");
                        return res.status(400).json({
                            success: false,
                            message: "Invalid category code in batch",
                            errors: [{
                                line: lineIndex + 1,
                                field: "speech_act_code",
                                value: speech,
                                reason: "Code not found in speech_act_categories"
                            }]
                        });
                    }
                }

                // Validate narrative_function_code if provided
                if (narrative && narrative !== "NULL") {
                    const narrativeCheck = await client.query(
                        "SELECT 1 FROM narrative_function_categories WHERE category_code = $1 AND is_active = true",
                        [narrative]
                    );
                    if (narrativeCheck.rows.length === 0) {
                        await client.query("ROLLBACK");
                        return res.status(400).json({
                            success: false,
                            message: "Invalid category code in batch",
                            errors: [{
                                line: lineIndex + 1,
                                field: "narrative_function_code",
                                value: narrative,
                                reason: "Code not found in narrative_function_categories"
                            }]
                        });
                    }
                }

                // Validate outcome intent codes if provided
                if (intents && intents !== "NULL" && intents !== "") {
                    const intentCodes = intents.split(",").map(x => x.trim());
                    const invalidIntents = [];
                    
                    for (const code of intentCodes) {
                        if (!code) continue;
                        const intentCheck = await client.query(
                            "SELECT 1 FROM outcome_intent_categories WHERE category_code = $1 AND is_active = true",
                            [code]
                        );
                        if (intentCheck.rows.length === 0) {
                            invalidIntents.push(code);
                        }
                    }
                    
                    if (invalidIntents.length > 0) {
                        await client.query("ROLLBACK");
                        return res.status(400).json({
                            success: false,
                            message: "Invalid outcome intent codes in batch",
                            errors: invalidIntents.map(code => ({
                                line: lineIndex + 1,
                                field: "outcome_intent_code",
                                value: code,
                                reason: "Code not found in outcome_intent_categories"
                            }))
                        });
                    }
                }

                // All validations passed for this line, proceed with insert
                const trainingId = await generateHexId("ltlm_training_example_id");

                await client.query(`
                    INSERT INTO ltlm_training_examples (
                        training_example_id,
                        speaker_character_id,
                        utterance_text,
                        dialogue_function_code,
                        speech_act_code,
                        narrative_function_code,
                        pad_pleasure,
                        pad_arousal,
                        pad_dominance,
                        emotion_register_id,
                        source,
                        is_canonical,
                        difficulty,
                        tags,
                        category_confidence,
                        notes,
                        created_by
                    ) VALUES (
                        $1, $2, $3,
                        $4, $5, $6,
                        $7, $8, $9,
                        NULL,
                        'cms_ltlm',
                        true,
                        1,
                        '{}',
                        1.0,
                        '',
                        $10
                    )
                `, [
                    trainingId,
                    speaker_character_id,
                    utterance,
                    dialogue === "NULL" ? null : dialogue,
                    speech === "NULL" ? null : speech,
                    narrative === "NULL" ? null : narrative,
                    parseFloat(padP),
                    parseFloat(padA),
                    parseFloat(padD),
                    created_by
                ]);

                if (intents && intents !== "NULL" && intents !== "") {
                    for (const code of intents.split(",").map(x => x.trim())) {
                        if (!code) continue;
                        const intentId = await generateHexId("ltlm_outcome_intent_id");

                        await client.query(`
                            INSERT INTO ltlm_training_outcome_intents (
                                ltlm_outcome_intent_id,
                                training_example_id,
                                outcome_intent_code
                            ) VALUES ($1, $2, $3)
                        `, [
                            intentId,
                            trainingId,
                            code
                        ]);
                    }
                }

                inserted++;
            }
        }

        await client.query("COMMIT");
        return res.json({ success: true, inserted });

    } catch (e) {
        await client.query("ROLLBACK");
        console.error("LTLM POST error:", e);
        return res.status(500).json({ success: false, message: "Insert failed", error: e.message });
    } finally {
        client.release();
    }
});

export default router;