import cotwQueryEngine from "./cotwQueryEngine.js";
import { searchEntityAllTiers } from "../utils/tieredEntitySearch.js";
import fetch from "node-fetch";

async function fetchTableConcept(tableName, session) {
  const baseUrl = process.env.GOD_MODE_BASE_URL || "http://localhost:3000";
  const url = `${baseUrl}/api/god-mode/concept/${encodeURIComponent(tableName)}`;

  const headers = {
    "Content-Type": "application/json"
  };

  const res = await fetch(url, { method: "GET", headers, credentials: "include" });
  if (!res.ok) {
    throw new Error(`God Mode concept fetch failed with status ${res.status}`);
  }

  const data = await res.json();
  if (!data.success || !data.concept) {
    throw new Error(`No system_concept found for ${tableName}`);
  }

  return data.concept;
}

/**
 * GodModeDebugger
 * --------------------------------------------------------------
 * Centralized, production-ready God Mode inspector.
 *
 * Requirements:
 *   - User MUST be level 11
 *   - Command MUST start with "God Mode:"
 */
export default async function GodModeDebugger(intent, user, command, session) {
  if (!user || user.access_level !== 11) {
    return null;
  }

  const lower = command.toLowerCase();
  if (!lower.startsWith("god mode:")) {
    return null;
  }

  const cleanCommand = command.replace(/god mode\s*:?\s*/i, "").trim();

  let debugLog = "";
  let finalEntityUsed = null;
  let finalEntityType = null;
  let finalImage = null;

  try {
    debugLog += "===== GOD MODE DEBUGGER =====\n";
    debugLog += `Original: ${command}\n`;
    debugLog += `Cleaned: ${cleanCommand}\n`;
    debugLog += `Intent Type: ${intent.type}\n`;
    debugLog += `Matcher Method: ${intent.matcherMethod}\n`;
    debugLog += `Entity: ${intent.entity}\n`;
    debugLog += `Confidence: ${intent.confidence}\n\n`;

    // 1) Check for schema/table questions first
    const schemaMatch = cleanCommand.match(/what\s+is\s+in\s+([a-zA-Z0-9_]+)\??/i)
      || cleanCommand.match(/show\s+schema\s+([a-zA-Z0-9_]+)\??/i)
      || cleanCommand.match(/describe\s+table\s+([a-zA-Z0-9_]+)\??/i);

    if (schemaMatch) {
      const tableName = schemaMatch[1];
      debugLog += "Detected schema question for table: " + tableName + "\n";

      try {
        const concept = await fetchTableConcept(tableName, session);
        const cj = concept.concept_json || {};
        const schema = cj.schema || {};
        const metadata = cj.metadata || {};
        const deps = cj.dependencies || {};
        const tableLevel = deps.table_level || {};
        const inbound = tableLevel.depended_on_by || [];

        const columns = schema.columns || [];
        const pk = schema.primary_key || [];
        const rowCount = metadata.row_count;
        const estimated = metadata.row_count_estimated;

        let summaryLines = [];

        summaryLines.push(`Table "${tableName}" is a database_table in schema "${metadata.table_schema}".`);
        summaryLines.push(`It has ${columns.length} columns and approximately ${rowCount} rows${estimated ? " (estimated)" : ""}.`);

        if (pk.length > 0) {
          summaryLines.push(`Primary key: ${pk.join(", ")}.`);
        }

        const importantCols = columns
          .filter(c => ["character_id", "id", "created_at", "updated_at", "category"].includes(c.name))
          .map(c => `${c.name} (${c.type}${c.nullable ? ", nullable" : ", not null"})`);

        if (importantCols.length > 0) {
          summaryLines.push("Key columns: " + importantCols.join("; ") + ".");
        }

        if (inbound.length > 0) {
          const byTable = {};
          inbound.forEach(fk => {
            if (!byTable[fk.table]) byTable[fk.table] = [];
            byTable[fk.table].push(fk.their_column);
          });
          const inboundSummaries = Object.entries(byTable)
            .slice(0, 10)
            .map(([t, cols]) => `${t} (${Array.from(new Set(cols)).join(", ")})`);
          summaryLines.push(`Other tables depending on this table (${inbound.length} FKs, showing up to 10): ${inboundSummaries.join("; ")}.`);
        }

        const output = summaryLines.join(" ");

        return {
          mode: "god",
          output,
          debugLog,
          entityUsed: tableName,
          entityType: "database_table",
          queryType: "schema_inspect",
          image: null,
          concept
        };
      } catch (schemaErr) {
        debugLog += "Schema branch error: " + schemaErr.message + "\n";
        // Fall through to standard entity-based God Mode below
      }
    }

    const realm = intent.realm;
    debugLog += `Realm: ${realm}\n\n`;

    // 2) Existing entity-focused God Mode
    debugLog += "===== TIERED SEARCH =====\n";

    const tierData = await searchEntityAllTiers(
      intent.entity || cleanCommand,
      realm
    );

    debugLog += `Query: ${tierData.query}\n`;
    debugLog += `Latency: ${tierData.total_latency_ms}ms\n\n`;

    const tiers = [
      { label: "TIER 1 (Exact)", data: tierData.tier1 },
      { label: "TIER 2 (Phonetic)", data: tierData.tier2 },
      { label: "TIER 3 (Fuzzy)", data: tierData.tier3 }
    ];

    for (const t of tiers) {
      debugLog += `--- ${t.label} ---\n`;
      if (t.data && t.data.count > 0) {
        debugLog += `Count: ${t.data.count}\nMethod: ${t.data.method}\n`;
        for (const m of t.data.matches) {
          debugLog += `- ${m.entity_name} (${m.entity_type}) [${m.entity_id}]\n`;
        }
      } else {
        debugLog += "No matches.\n";
      }
      debugLog += "\n";
    }

    debugLog += "===== USER-FACING RESULT =====\n";

    const best =
      tierData.tier1?.matches?.[0] ||
      tierData.tier2?.matches?.[0] ||
      tierData.tier3?.matches?.[0] ||
      null;

    if (!best) {
      return {
        mode: "god",
        output: `No matches found for "${intent.entity}".`,
        debugLog
      };
    }

    const userIntent = {
      type: intent.type,
      entity: best.entity_name,
      entityData: best,
      realm,
      original: command
    };

    const userResult = await cotwQueryEngine.executeQuery(userIntent, user);

    finalEntityUsed = best.entity_name;
    finalEntityType = best.entity_type;

    let cleanOutput = userResult.message || "(no summary)";
    finalImage = userResult.data?.image_url || userResult.image || null;

    return {
      mode: "god",
      output: cleanOutput,
      debugLog,
      entityUsed: finalEntityUsed,
      entityType: finalEntityType,
      queryType: intent.type,
      image: finalImage
    };
  } catch (err) {
    return {
      mode: "god",
      output: "God Mode failed to process.",
      error: err.message,
      debugLog
    };
  }
}
