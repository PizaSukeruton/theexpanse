import { Server } from "socket.io";
import * as omiyageService from "../services/omiyageService.js";
import claudeBrain from "./ClaudeBrain.js";
import bcrypt from "bcryptjs";
import pool from "../db/pool.js";

import modeRouter from "./modeRouter.js";
import runStandardQuery from "./runStandardQuery.js";
import TanukiModeRouter from "./TanukiModeRouter.js";
import GodModeDebugger from "./GodModeDebugger.js";
import { getFirstLoginWelcomeBeat } from "../services/narrativeWelcomeService.js";
const seenWelcomeUsers = new Set();

async function maybeEmitOmiyage(socket) {
  try {
    const result = await omiyageService.checkAndInitiateOmiyage(socket.userId);
    
    if (!result) {
      // Already completed, inventory empty, or other skip condition
      return;
    }
    
    // Handle resume of already-resolved offer (user disconnected after choosing)
    if (result.type === 'resume_resolved') {
      console.log(`[Omiyage] Resuming resolved offer ${result.choiceId}, triggering fulfilment`);
      // Auto-fulfil and emit result
      const fulfilResult = await omiyageService.fulfilOmiyage(result.choiceId, socket.ownedCharacterId);
      const narrative = await omiyageService.buildFulfilmentNarrative(fulfilResult.object);
      socket.emit('omiyage:fulfilled', {
        choiceId: result.choiceId,
        object: fulfilResult.object,
        narrative
      });
      return;
    }
    
    // Emit offer to client
    socket.emit('omiyage:offer', {
      choiceId: result.choiceId,
      offerCount: result.offerCount,
      narrative: result.narrative,
      giverName: 'Claude The Tanuki'
    });
    
    console.log(`[Omiyage] Emitted offer ${result.choiceId} to ${socket.userId}`);
    
  } catch (err) {
    console.error('[Omiyage] Error in maybeEmitOmiyage:', err);
  }
}
import aliasTrainer from "./aliasTrainer.js";
import ContextMemoryManager from "./updateContextMemory.js";

import generateHexId from "../utils/hexIdGenerator.js";
import GiftEventHandler from "../knowledge/GiftEventHandler.js";

const giftEventHandler = new GiftEventHandler();
import cotwIntentMatcher from "./cotwIntentMatcher.js";
import { initializeRegistrationSockets } from "./registrationSocketHandler.js";

const contextMemory = new ContextMemoryManager();

function wrapSessionMiddleware(middleware) {
  return (socket, next) => middleware(socket.request, {}, next);
      }

export default function initializeWebSocket(httpServer, sessionMiddleware) {
  const io = new Server(httpServer, {
    cors: {
      origin: process.env.FRONTEND_ORIGIN || "http://localhost:3000",
      credentials: true
          }
  });

  const publicIo = io.of("/public");
  initializeRegistrationSockets(publicIo);

  publicIo.on("connection", (socket) => {
    console.log("ğŸŸ¢ /public socket connected:", socket.id);
    socket.on("disconnect", () =>
      console.log("ğŸ”´ /public socket disconnected:", socket.id)
    );
  });

  const terminalIo = io.of("/terminal");

  terminalIo.use(wrapSessionMiddleware(sessionMiddleware));

  terminalIo.use((socket, next) => {
    const sess = socket.request.session;
    if (!sess || !sess.userId) {
      return next(new Error("Unauthorized"));
          }
    socket.userId = sess.userId;
    socket.username = sess.username;
    socket.accessLevel = sess.accessLevel;
    socket.ownedCharacterId = sess.ownedCharacterId;
    next();
  });

  terminalIo.on("connection", (socket) => {
    console.log(`ğŸŸ¢ /terminal connected: ${socket.username} (lvl ${socket.accessLevel})`);
    (async () => {
      try {
              if (seenWelcomeUsers.has(socket.userId)) {
                console.log("[WelcomeDebug v2] skipping welcome, already seen for", socket.userId);
                return;
            }

      const welcomeBeat = await getFirstLoginWelcomeBeat(socket.userId, "700002");
        console.log("[WelcomeDebug v2] welcomeBeat on connect for", socket.userId, ":", welcomeBeat);
        if (welcomeBeat) {
          socket.emit("command-response", {
            mode: "tanuki",
            from: "Claude",
            welcome: true,
            welcomeBeat
          });

  seenWelcomeUsers.add(socket.userId);

  await maybeEmitOmiyage(socket);

  console.log("[OmiyageDebug] post-greeting hook reached for", socket.userId);
              }
      } catch (e) {
        console.error("[Socket] getFirstLoginWelcomeBeat on connect failed:", e);
            }
    })();


    socket.on("terminal-command", async (data) => {
      try {
        if (!socket.userId) {
          socket.emit("command-response", { error: "NOT AUTHENTICATED" });
          return;
        }

        const { command } = data;
        console.log("[DEBUG] Received terminal command:", command);

        const session = {
          id: socket.userId,
          username: socket.username,
          access_level: socket.accessLevel,
          context: socket.context || {}
        };

        const user = {
          userid: session.id,
          username: session.username,
          access_level: session.access_level,
          owned_character_id: socket.ownedCharacterId
        };

        // === CLAUDEBRAIN: Single unified call ===
        const response = await claudeBrain.processQuery(command, session, user);

        // Update socket context
        socket.context = response.context || session.context;

        console.log("[DEBUG] ClaudeBrain response:", response);
        socket.emit("command-response", response);

      } catch (err) {
        console.error("Terminal command error:", err);
        socket.emit("command-response", { error: "COMMAND FAILED" });
      }
    });
    socket.on("gift-wizard:get-realms", async (ack) => {
      if (!socket.userId) { ack?.({ success: false, error: "Not authenticated" });         return;       }
      try {
        const r = await pool.query("SELECT DISTINCT realm FROM public.locations ORDER BY realm");
        const realms = r.rows.map(x => x.realm);
        ack?.({ success: true, realms });
        socket.emit("gift-wizard:realms", { success: true, realms });
      } catch (e) {
        ack?.({ success: false, error: e.message });
        socket.emit("gift-wizard:error", { error: e.message });
            }
    });

    socket.on("gift-wizard:get-locations", async (data) => {
      if (!socket.userId)         return;
      try {
        const r = await pool.query(
          "SELECT location_id, name FROM public.locations WHERE realm = $1 ORDER BY name",
          [data.realm]
        );
        socket.emit("gift-wizard:locations", { success: true, locations: r.rows });
      } catch (e) {
        socket.emit("gift-wizard:error", { error: e.message });
            }
    });

    socket.on("gift-wizard:get-characters", async () => {
      if (!socket.userId)         return;
      try {
        const r = await pool.query(
          "SELECT character_id, character_name, category FROM public.character_profiles WHERE category NOT IN ('Knowledge Entity') LIMIT 20"
        );
        socket.emit("gift-wizard:characters", { success: true, characters: r.rows });
      } catch (e) {
        socket.emit("gift-wizard:error", { error: e.message });
            }
    });

    socket.on("gift-wizard:get-givers-only", async () => {
      if (!socket.userId)         return;
      try {
        const r = await pool.query(
          "SELECT DISTINCT cp.character_id, cp.character_name, cp.category FROM character_profiles cp JOIN character_inventory ci ON cp.character_id = ci.character_id WHERE cp.category NOT IN ('Knowledge Entity') ORDER BY cp.character_name"
        );
        socket.emit("gift-wizard:givers-only", { success: true, characters: r.rows });
      } catch (e) {
        socket.emit("gift-wizard:error", { error: e.message });
            }
    });

    socket.on("gift-wizard:get-giver-inventory", async (data) => {
      if (!socket.userId)         return;
      try {
        const r = await pool.query(
          "SELECT ci.inventory_entry_id, ci.object_id, o.object_name, o.object_type, o.rarity FROM character_inventory ci JOIN objects o ON ci.object_id = o.object_id WHERE ci.character_id = $1",
          [data.giver_id]
        );
        socket.emit("gift-wizard:giver-inventory", { success: true, items: r.rows });
      } catch (e) {
        socket.emit("gift-wizard:error", { error: e.message });
            }
    });

    socket.on("gift-wizard:create-event", async (data) => {
      if (!socket.userId) return socket.emit("gift-wizard:error", { error: "Not authenticated" });
      try {
        const eventId = await generateHexId("multiverse_event_id");
        const r = await pool.query(
          "INSERT INTO public.multiverse_events (event_id, realm, location, event_type, involved_characters, outcome, timestamp, notes) VALUES ($1,$2,$3,$4,$5,$6,$7,$8) RETURNING *",
          [
            eventId,
            data.realm,
            data.location?.name || "Unknown",
            "gift_exchange",
            JSON.stringify({ giver: data.giver_id, receiver: data.receiver_id }),
            data.outcome,
            new Date().toISOString(),
            data.notes
          ]
        );
        socket.emit("gift-wizard:event-created", { success: true, event: r.rows[0] });
      } catch (e) {
        socket.emit("gift-wizard:error", { error: e.message });
            }
    });

    socket.on("menu-wizard:create-button", async (data, ack) => {
      if (!socket.userId) return ack?.({ success: false, error: "Not authenticated" });
      if (socket.accessLevel !== 11) return ack?.({ success: false, error: "Unauthorized - God Mode required" });

      try {
        const menuId = await generateHexId("wizard_guide_id");
        const insertSql = `
          INSERT INTO wizard_guides (wizard_id, wizard_name, wizard_type, description, frontend_file, version, access_levels, is_active)
          VALUES ($1, $2, $3, $4, $5, $6, $7, true)
          RETURNING *
        `;
        const result = await pool.query(insertSql, [
          menuId,
          data.name,
          data.type || "menu_button",
          data.description || "",
          data.frontend_file || "",
          "1.0",
          [11]
        ]);
        ack?.({ success: true, wizard: result.rows[0] });
      } catch (e) {
        ack?.({ success: false, error: e.message });
            }
    });


    socket.on("omiyage:accept", async (payload) => {
      console.log("[Omiyage] accept received", { user: socket.userId, payload });
      
      try {
        const { choiceId, chosenNumber } = payload;
        
        if (!choiceId || !chosenNumber) {
          socket.emit('omiyage:error', { error: 'Missing choiceId or chosenNumber' });
          return;
        }
        
        // 1. Resolve the choice to a specific object
        const resolveResult = await omiyageService.resolveChoice(choiceId, chosenNumber);
        
        if (resolveResult.alreadyResolved) {
          console.log(`[Omiyage] Choice ${choiceId} already resolved, status: ${resolveResult.status}`);
          // If already fulfilled, just return success
          if (resolveResult.status === 'fulfilled') {
            socket.emit('omiyage:fulfilled', { choiceId, alreadyFulfilled: true });
            return;
          }
        }
        
        // 2. Fulfil the transfer
        const fulfilResult = await omiyageService.fulfilOmiyage(choiceId, socket.ownedCharacterId);
        
        // 3. Build narrative
        const narrative = await omiyageService.buildFulfilmentNarrative(fulfilResult.object);
        
        // 4. Emit success
        socket.emit('omiyage:fulfilled', {
          choiceId,
          object: fulfilResult.object,
          narrative,
          newInventoryEntryId: fulfilResult.newInventoryEntryId
        });
        
        console.log(`[Omiyage] Fulfilled ${choiceId} - ${fulfilResult.object.object_name} to ${socket.userId}`);
        
      } catch (err) {
        console.error('[Omiyage] accept error:', err);
        socket.emit('omiyage:error', { error: err.message });
      }
    });

    socket.on("omiyage:decline", async (payload) => {
      console.log("[Omiyage] decline received", { user: socket.userId, payload });
      
      try {
        const { choiceId } = payload;
        
        if (!choiceId) {
          socket.emit('omiyage:error', { error: 'Missing choiceId' });
          return;
        }
        
        const narrative = await omiyageService.declineOmiyage(choiceId);
        
        socket.emit('omiyage:declined', {
          choiceId,
          narrative
        });
        
        console.log(`[Omiyage] Declined ${choiceId} by ${socket.userId}`);
        
      } catch (err) {
        console.error('[Omiyage] decline error:', err);
        socket.emit('omiyage:error', { error: err.message });
      }
    });

    socket.on("omiyage:deferral", async (payload) => {
      // Deferral = user closes modal without choosing, offer remains pending
      console.log("[Omiyage] deferral received", { user: socket.userId, payload });
      // No state change needed - offer stays in 'chosen_unresolved'
      // Will resume on next connect
    });
    socket.on("disconnect", () => {
      console.log(`ğŸ”´ /terminal disconnected: ${socket.username}`);
    });
  });

  return io;
      }


