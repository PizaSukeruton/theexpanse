// backend/TSE/StudentComponent2.js
// TSE Student 2.0 â€” FSRS-aware, deterministic, chunker-agnostic, hex-safe, event-driven

import pkg from 'pg';
import crypto from 'crypto';
const { Pool } = pkg;

export default class StudentComponent2 {

    constructor(pool, eventBus = null) {
        if (!pool) throw new Error("StudentComponent2 requires a PostgreSQL pool.");
        this.pool = pool;

        // optional event bus (Socket.IO, EventEmitter, or custom dispatcher)
        this.eventBus = eventBus;

        // node identifier for hex-safe ID generation
        this.nodeId = crypto.randomBytes(1).toString("hex").toUpperCase();

        this.initialized = false;
    }

    async initialize() {
        this.initialized = true;
        console.log("[TSE-Student2] Initialized with node ID:", this.nodeId);
        return true;
    }

    // ---------------------------------------------------------------------
    //  HEX-SAFE, ZERO-COLLISION ID GENERATOR
    // ---------------------------------------------------------------------
    generateRecordId() {
        const timestamp = Date.now().toString(16).toUpperCase();
        const rand = crypto.randomBytes(2).toString("hex").toUpperCase();
        return `#9S${timestamp}${rand}${this.nodeId}`;
    }

    // ---------------------------------------------------------------------
    //  MAIN ENTRYPOINT FOR KNOWLEDGE CHUNKING
    // ---------------------------------------------------------------------
    async processKnowledgeBase(text, cycleId, teacherRecordId = null) {
        if (!this.initialized) throw new Error("StudentComponent2 not initialized.");

        const recordId = this.generateRecordId();

        const response = await fetch("http://localhost:8000/chunk_knowledge/", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text, config: {} })
        });

        if (!response.ok) {
            throw new Error(`Chunker API error: ${response.status}`);
        }

        const chunker = await response.json();
        const features = this.extractChunkFeatures(chunker.chunks);
        const fsrs = this.computeFSRSUpdate(features);

        const result = await this.saveRecord(
            recordId,
            cycleId,
            teacherRecordId || this.makeTeacherRef(cycleId, "K"),
            "knowledge",
            features,
            chunker,
            fsrs
        );

        this.dispatchEvent("tse.student.knowledge", result);

        return result;
    }

    // ---------------------------------------------------------------------
    //  MAIN ENTRYPOINT FOR CONVERSATION ANALYSIS
    // ---------------------------------------------------------------------
    async processConversation(text, cycleId, userId = "anonymous", teacherRecordId = null) {
        if (!this.initialized) throw new Error("StudentComponent2 not initialized.");

        const recordId = this.generateRecordId();

        const response = await fetch("http://localhost:8000/chunk_conversation/", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text, config: {} })
        });

        if (!response.ok) {
            throw new Error(`Conversation Chunker API error: ${response.status}`);
        }

        const chunker = await response.json();
        const features = this.extractChunkFeatures(chunker.chunks);

        const result = await this.saveRecord(
            recordId,
            cycleId,
            teacherRecordId || this.makeTeacherRef(cycleId, "C"),
            "conversation",
            features,
            chunker,
            { conversation_flow: features.patternDensity }
        );

        this.dispatchEvent("tse.student.conversation", result);

        return result;
    }

    // ---------------------------------------------------------------------
    //  PRESENT STORYTELLING TASK (STUDENT-DRIVEN)
    // ---------------------------------------------------------------------
    async handleKnowledgeCycle(cycleId, characterId, taskTypeId, teacherRecordId) {
        if (!this.initialized) throw new Error("StudentComponent2 not initialized.");

        const recordId = this.generateRecordId();

        const payload = {
            outcome_type: "storytelling_lesson_presented",
            task_type_id: taskTypeId,
            character_id: characterId,
            cycle_id: cycleId,
            status: "awaiting_response"
        };

        const result = await this.saveRecord(
            recordId,
            cycleId,
            teacherRecordId,
            "lesson",
            { lesson_ready: true },
            { raw: "lesson" },
            { readiness: 1.0 },
            payload
        );

        this.dispatchEvent("tse.student.lesson", result);

        return {
            type: "storytelling_lesson_presented",
            record_id: recordId,
            character_id: characterId,
            status: "awaiting_response",
            cycle_id: cycleId
        };
    }

    // ---------------------------------------------------------------------
    //  CHUNKER-AGNOSTIC FEATURE EXTRACTOR
    // ---------------------------------------------------------------------
    extractChunkFeatures(chunks = []) {
        if (!Array.isArray(chunks) || chunks.length === 0) {
            return {
                chunkCount: 0,
                avgConfidence: 0,
                categoryDistribution: {},
                entityDensity: 0,
                patternDensity: 0
            };
        }

        let totalConfidence = 0;
        let confCount = 0;

        const categories = {};
        let entities = 0;
        let patterns = 0;

        for (const c of chunks) {
            // confidence (fallbacks safely)
            if (c.metadata?.confidence !== undefined) {
                totalConfidence += c.metadata.confidence;
                confCount++;
            }

            // categories
            const cat = c.metadata?.category || "general";
            categories[cat] = (categories[cat] || 0) + 1;

            // entity detection (universal)
            if (
                c.strategy === "ENTITY" ||
                c.chunking_strategy === "entity" ||
                c.metadata?.category === "entity" ||
                c.metadata?.slot_category_hint?.includes("entity")
            ) {
                entities++;
            }

            // narrative / conversational patterns
            if (
                c.metadata?.slot_category_hint?.includes("character") ||
                c.metadata?.slot_category_hint?.includes("narrative") ||
                c.strategy === "CANDIDATE_ENTITY"
            ) {
                patterns++;
            }
        }

        return {
            chunkCount: chunks.length,
            avgConfidence: confCount > 0 ? totalConfidence / confCount : 0,
            categoryDistribution: categories,
            entityDensity: entities / chunks.length,
            patternDensity: patterns / chunks.length
        };
    }

    // ---------------------------------------------------------------------
    //  FSRS-LIKE UPDATE CALCULATOR (DETERMINISTIC)
    // ---------------------------------------------------------------------
    computeFSRSUpdate(features) {
        // Deterministic bounded calculations
        const stability = Number((0.4 + features.avgConfidence * 0.6).toFixed(4));
        const difficulty = Number((5.0 - features.entityDensity * 3).toFixed(4));
        const retrievability = Number((features.avgConfidence).toFixed(4));

        const nextInterval = Math.max(
            1,
            Math.round(stability * (retrievability * 5 + 1))
        );

        return {
            stability,
            difficulty,
            retrievability,
            nextInterval
        };
    }

    // ---------------------------------------------------------------------
    //  DATABASE INSERT (TRANSACTION SAFE)
    // ---------------------------------------------------------------------
    async saveRecord(
        recordId,
        cycleId,
        teacherRecordId,
        type,
        features,
        chunker,
        fsrs,
        customOutcome = null
    ) {
        const client = await this.pool.connect();
        try {
            await client.query("BEGIN");

            const outcome =
                customOutcome ||
                {
                    outcome_type: type,
                    cycle_id: cycleId,
                    learned: type === "knowledge"
                };

            const insertQuery = `
                INSERT INTO tse_student_records (
                    record_id, cycle_id, teacher_record_id, student_sequence,
                    real_world_outcome, success_metrics, quality_indicators,
                    user_engagement, character_similarity_accuracy
                ) VALUES (
                    $1, $2, $3,
                    (SELECT COALESCE(MAX(student_sequence), 0) + 1 FROM tse_student_records WHERE cycle_id=$2),
                    $4, $5, $6, $7, $8
                ) RETURNING *;
            `;

            const dbResult = await client.query(insertQuery, [
                recordId,
                cycleId,
                teacherRecordId,
                outcome,
                features,
                { fsrs, confidence: features.avgConfidence },
                { engagement: type },
                features.patternDensity
            ]);

            await client.query("COMMIT");

            return {
                record_id: recordId,
                type,
                cycle_id: cycleId,
                teacher_record_id: teacherRecordId,
                feature_vector: features,
                fsrs_effects: fsrs,
                summary: this.makeSummary(type, features),
                chunker_result: chunker,
                db_record: dbResult.rows[0]
            };
        } catch (err) {
            await client.query("ROLLBACK");
            console.error("StudentComponent2 DB Error:", err);
            throw err;
        } finally {
            client.release();
        }
    }

    // ---------------------------------------------------------------------
    //  HELPERS
    // ---------------------------------------------------------------------
    makeTeacherRef(cycleId, prefix) {
        return `${prefix}${cycleId.substring(1)}`;
    }

    makeSummary(type, features) {
        return `${type.toUpperCase()} | chunks=${features.chunkCount}, conf=${features.avgConfidence.toFixed(2)}, patterns=${features.patternDensity.toFixed(2)}`;
    }

    dispatchEvent(event, payload) {
        if (!this.eventBus) return;
        try {
            this.eventBus.emit(event, payload);
        } catch (err) {
            console.error("[TSE-Student2] Event dispatch error:", err);
        }
    }
}

