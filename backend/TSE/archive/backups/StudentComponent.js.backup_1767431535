import traitManager from "../traits/TraitManager.js";
import generateHexId from "../utils/hexIdGenerator.js";
import pool from "../db/pool.js";
import MechanicalBrain_v2 from "./TanukiEngine/MechanicalBrain_v2.js";
import TriggerPhraseDetector from "./TanukiEngine/TriggerPhraseDetector.js";

export default class StudentComponent {
  constructor() {
    this.pool = pool;
    // Fix: traitManager is already an instance, so we don't use 'new'
    this.traits = traitManager;
    this.nodeId = Math.floor(Math.random() * 256).toString(16).toUpperCase();
  }

  async initialize() {
    return true;
  }

  async learn(characterId, knowledgeId, task) {
    const attemptId = await generateHexId("tse_attempt_id");

    let attemptText = "";

    // Check for Tanuki Mode trigger
    const detector = new TriggerPhraseDetector();
    const triggerResult = detector.detect(task.input);

    if (triggerResult.matched) {
      // Route to MechanicalBrain for Tanuki Mode
      const MechanicalBrain = new MechanicalBrain_v2();
      attemptText = await MechanicalBrain.generateResponse(
        triggerResult.cleanedInput,
        triggerResult.characterId
      );
    } else {
      // Use existing task-based logic
      switch (task.taskType) {
        case "cause_effect_rewrite":
          attemptText = this._attemptCauseEffectRewrite(task.input);
          break;
        case "sentence_clarity_rewrite":
          attemptText = this._attemptSentenceClarityRewrite(task.input);
          break;
        case "summarize_core_point":
          attemptText = this._attemptSummarizeCorePoint(task.input);
          break;
        case "communication_quality":
          attemptText = this._attemptCommunicationQuality(task.input, task);
          break;
        case "clarification":
          attemptText = this._attemptCommunicationQuality(task.input, task);
          break;
        default:
          attemptText = "I do not understand this task yet.";
          break;
      }
    }

    attemptText = await this._applyPersonalityErrors(characterId, attemptText);

    return {
      attemptId,
      taskId: task.taskId,
      characterId,
      knowledgeId,
      attemptText,
      studentNode: this.nodeId
    };
  }

  _attemptCauseEffectRewrite(text) {
    if (!text || typeof text !== "string") return "No input provided.";
    let result = text.trim()
      .replace(/\s+and then\s+/gi, (match) => Math.random() > 0.5 ? ' → so ' : ' → therefore ')
      .replace(/\s+and\s+/gi, ', because ')
      .replace(/\.\s*$/, '. As a result...');
    return result;
  }

  _attemptSentenceClarityRewrite(text) {
    if (!text || typeof text !== "string") return "No input provided.";
    let result = text.trim()
      .replace(/\s+and\s+/gi, '. ')
      .replace(/\s*,\s*/g, '. ')
      .split('. ')
      .map(s => s.trim())
      .filter(s => s.length > 5)
      .join('. ');
    return result || text.trim();
  }

  _attemptSummarizeCorePoint(text) {
    if (!text || typeof text !== "string") return "No input provided.";
    const sentences = text.split(/(?<=[.!?])\s+/)
      .map(s => s.trim())
      .filter(Boolean);
    if (sentences.length === 0) return text.trim();
    const take = Math.max(1, Math.ceil(sentences.length * 0.5));
    let summary = sentences.slice(0, take).join('. ');
    if (take < sentences.length) summary += '...';
    else if (!summary.endsWith('.')) summary += '.';
    return summary;
  }


  _attemptCommunicationQuality(text, task) {
    if (!text || typeof text !== "string") return "No input provided.";
    let result = text.trim()
      .replace(/^Explain /i, "Let me explain: ")
      .replace(/\s+are\s+/gi, " involve ")
      .replace(/\.\s*$/, ", and that's pretty neat!");
    result += " I'd love to hear what you think!";
    if (task?.metadata?.target_verbosity === 'moderate') {
      result += " We can explore this together in a balanced way!";
    }
    return result;
  }

  async _applyPersonalityErrors(characterId, text) {
    const traits = await this.traits.getTraitVector(characterId);
    let result = text;

    const impulsive = traits["#0000A1"] || 50;
    const forgetful = traits["#0000B2"] || 50;
    const detailOriented = traits["#0000C3"] || 50;
    const overconfident = traits["#0000D4"] || 50;

    if (impulsive > 70 && result.includes(".")) {
      const parts = result.split(".");
      if (parts.length > 1) parts.pop();
      result = parts.join(".") + ".";
    }

    if (forgetful > 65) {
      result = result.replace(/\b(because|so|therefore|as a result|which led to|which caused)\b/gi, "...");
    }

    if (detailOriented > 60) {
      result += " (note: attention to details included)";
    }

    if (overconfident > 75) {
      result = "I know this! " + result;
    }

    return result;
  }
}
