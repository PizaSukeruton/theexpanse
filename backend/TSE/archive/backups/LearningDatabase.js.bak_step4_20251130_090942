import pool from "../db/pool.js";
import generateHexId from "../utils/hexIdGenerator.js";

export default class LearningDatabase {

    constructor(dbPool) {
        this.pool = dbPool || pool;
        this.embeddingSize = 32;
    }

    //----------------------------------------------------------------------
    // Deterministic JavaScript embedding generator (offline, no API)
    //----------------------------------------------------------------------
    generateEmbedding(text) {
        if (!text) return Array(this.embeddingSize).fill(0);

        let hash = 0;
        for (let i = 0; i < text.length; i++) {
            hash = ((hash << 5) - hash) + text.charCodeAt(i);
            hash |= 0;
        }

        const vec = [];
        for (let i = 0; i < this.embeddingSize; i++) {
            const val = Math.sin(hash + i * 97) * 0.5 + Math.cos(hash * (i + 3)) * 0.5;
            vec.push(Number(val.toFixed(6)));
        }

        return vec;
    }

    //----------------------------------------------------------------------
    // createCycle() with embeddings patched in
    //----------------------------------------------------------------------
    async createCycle(acquired) {
        const client = await this.pool.connect();
        try {
            await client.query("BEGIN");

            let knowledgeId = acquired.knowledge_id;
            const reused = acquired.reused === true;

            // ------------------------------------------------------
            // 0. NEW KNOWLEDGE: Insert into knowledge_items
            // ------------------------------------------------------
            if (!reused) {

                knowledgeId = await generateHexId("knowledge_item_id");

                const embedding = this.generateEmbedding(
                    acquired.content || acquired.original_query || ""
                );

                const insertKnowledge = `
                    INSERT INTO knowledge_items (
                        knowledge_id,
                        content,
                        semantic_embedding,
                        domain_id,
                        source_type,
                        acquisition_timestamp,
                        initial_character_id,
                        initial_strength,
                        complexity_score,
                        concept
                    )
                    VALUES ($1,$2,$3,$4,'tse_cycle',NOW(),$5,$6,$7,$8)
                `;

                await client.query(insertKnowledge, [
                    knowledgeId,
                    acquired.content,
                    JSON.stringify(embedding),
                    acquired.domainId || null,
                    acquired.characterId,
                    1,
                    acquired.complexity_score || 0.5,
                    acquired.concept
                ]);
            }

            // ------------------------------------------------------
            // 1. ALWAYS: Insert cycle log
            // ------------------------------------------------------
            const cycleId = await generateHexId("tse_cycle_id");

            const insertCycle = `
                INSERT INTO tse_cycles (
                    cycle_id,
                    character_id,
                    knowledge_id,
                    source_query,
                    cycle_timestamp,
                    was_reused
                )
                VALUES ($1,$2,$3,$4,NOW(),$5)
                RETURNING *
            `;

            const cycleResult = await client.query(insertCycle, [
                cycleId,
                acquired.characterId,
                knowledgeId,
                acquired.original_query || acquired.content || null,
                reused
            ]);

            await client.query("COMMIT");

            return {
                status: "ok",
                reused,
                knowledge_id: knowledgeId,
                cycle: cycleResult.rows[0]
            };

        } catch (err) {
            await client.query("ROLLBACK");
            console.error("[LearningDB.createCycle] ERROR:", err);
            throw err;
        } finally {
            client.release();
        }
    }
}
