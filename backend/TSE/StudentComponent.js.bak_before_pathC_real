// StudentComponent_pathC.js
// Path C: Added simple in-memory memory + hint prepend on low score
// - Uses a global Map to track last 3 attempts + scores per knowledgeId per character
// - On score <3, prepends 1-2 keywords from correct answer (from DB)
// - Everything else is identical to your original version

import traitManager from "../traits/TraitManager.js";
import generateHexId from "../utils/hexIdGenerator.js";
import pool from "../db/pool.js";
import MechanicalBrain_v2 from "./TanukiEngine/MechanicalBrain_v2.js";
import TriggerPhraseDetector from "./TanukiEngine/TriggerPhraseDetector.js";

// Simple in-memory memory: characterId → knowledgeId → { attempts: [], scores: [] }
// Last 3 attempts/scores only - lost on restart (good for testing)
const studentMemory = new Map(); // global for this process

export default class StudentComponent {
  constructor() {
    this.pool = pool;
    this.traits = traitManager;
    this.nodeId = Math.floor(Math.random() * 256)
      .toString(16)
      .toUpperCase()
      .padStart(2, "0");
  }

  async initialize() {
    return true;
  }

  async learn(characterId, knowledgeId, task, userResponseText = null) {
    const attemptId = await generateHexId("tse_attempt_id");

    let attemptText = "";
    let isRealInput = false;

    if (userResponseText && typeof userResponseText === "string" && userResponseText.trim()) {
      attemptText = userResponseText.trim();
      isRealInput = true;
    } else {
      const detector = new TriggerPhraseDetector();
      const triggerResult = detector.detect(task.input || "");

      if (triggerResult.matched) {
        const brain = new MechanicalBrain_v2();
        attemptText = await brain.generateResponse(
          triggerResult.cleanedInput,
          triggerResult.characterId || characterId
        );
      } else {
        attemptText = await this._generateSimulatedResponse(task);
      }
    }

    // Path C: Add hint prepend if previous score was low
    attemptText = await this._addHintOnLowScore(characterId, knowledgeId, task, attemptText);

    attemptText = await this._applyPersonalityErrors(characterId, attemptText);

    const now = new Date();
    const metadata = {
      responseLength: attemptText.length,
      wordCount: attemptText.trim().split(/\s+/).filter(Boolean).length,
      timestamp: now.toISOString(),
      isRealInput,
      outcomeIntent: task.metadata?.target_outcome_intent || "neutral",
    };

    return {
      attemptId,
      taskId: task.taskId,
      characterId,
      knowledgeId,
      attemptText,
      studentNode: this.nodeId,
      metadata,
    };
  }

  // Path C: Simple memory + hint logic
  async _addHintOnLowScore(characterId, knowledgeId, task, text) {
    if (!knowledgeId) return text;

    // Get or create memory for this character/knowledgeId
    const key = `${characterId}:${knowledgeId}`;
    if (!studentMemory.has(key)) {
      studentMemory.set(key, { attempts: [], scores: [] });
    }
    const mem = studentMemory.get(key);

    // If we have previous scores and last one was bad (<3)
    if (mem.scores.length > 0 && mem.scores[mem.scores.length - 1] < 3) {
      try {
        const res = await pool.query(
          `SELECT content::jsonb->>'answer_statement' AS answer,
                  content::jsonb->>'teaching_statement' AS teaching
           FROM knowledge_items WHERE knowledge_id = $1`,
          [knowledgeId]
        );
        const row = res.rows[0] || {};
        const correct = row.answer || row.teaching || "";
        if (correct) {
          // Extract 1-2 keywords (simple split)
          const words = correct.split(/\s+/).filter(w => w.length > 3);
          const hintWords = words.slice(0, Math.min(2, words.length));
          if (hintWords.length > 0) {
            return hintWords.join(" ") + "... " + text;
          }
        }
      } catch (err) {
        console.warn("[PathC] Hint lookup failed:", err.message);
      }
    }

    return text;
  }

  async _generateSimulatedResponse(task) {
    const taskType = (task.taskType || "").toLowerCase();

    switch (taskType) {
      case "recall":
        return `I remember: ${task.input || "the fact"}.`;

      case "application":
        return `Applying it: ${task.input || "example usage"}.`;

      case "review":
        return `Reviewing: ${task.input || "key points so far"}.`;

      case "cause_effect_rewrite":
        return this._attemptCauseEffectRewrite(task.input || "");

      case "sentence_clarity_rewrite":
        return this._attemptSentenceClarityRewrite(task.input || "");

      case "summarize_core_point":
        return this._attemptSummarizeCorePoint(task.input || "");

      case "communication_quality":
      case "clarification":
        return this._attemptCommunicationQuality(task.input || "", task);

      default:
        return "I do not understand this task yet.";
    }
  }

  _attemptCauseEffectRewrite(text) {
    if (!text) return "No input provided.";
    return text.trim()
      .replace(/\s+and then\s+/gi, () => (Math.random() > 0.5 ? " → so " : " → therefore "))
      .replace(/\s+and\s+/gi, ", because ")
      .replace(/\.\s*$/, ". As a result...");
  }

  _attemptSentenceClarityRewrite(text) {
    if (!text) return "No input provided.";
    return text
      .trim()
      .replace(/\s+and\s+/gi, ". ")
      .replace(/\s*,\s*/g, ". ")
      .split(". ")
      .map(s => s.trim())
      .filter(s => s.length > 5)
      .join(". ");
  }

  _attemptSummarizeCorePoint(text) {
    if (!text) return "No input provided.";
    const sentences = text.split(/(?<=[.!?])\s+/).map(s => s.trim()).filter(Boolean);
    if (!sentences.length) return text.trim();

    const take = Math.max(1, Math.ceil(sentences.length * 0.5));
    let summary = sentences.slice(0, take).join(". ");
    if (take < sentences.length) summary += "...";
    else if (!summary.endsWith(".")) summary += ".";
    return summary;
  }

  _attemptCommunicationQuality(text, task) {
    if (!text) return "No input provided.";
    let result = text.trim()
      .replace(/^Explain /i, "Let me share: ")
      .replace(/\s+are\s+/gi, " involve ");

    if (!result.endsWith(".") && !result.endsWith("!") && !result.endsWith("?")) {
      result += ".";
    }

    return result;
  }

  async _applyPersonalityErrors(characterId, text) {
    const traits = await this.traits.getTraitVector(characterId);
    let result = text || "";

    const impulsive       = traits["#0000A1"] ?? 50;
    const forgetful       = traits["#0000B2"] ?? 50;
    const detailOriented  = traits["#0000C3"] ?? 50;
    const overconfident   = traits["#0000D4"] ?? 50;

    if (impulsive > 70 && result.includes(".")) {
      const parts = result.split(".");
      if (parts.length > 1) parts.pop();
      result = parts.join(".") + ".";
    }

    if (forgetful > 65) {
      result = result.replace(
        /\b(because|so|therefore|as a result|which led to|which caused)\b/gi,
        "..."
      );
    }

    if (overconfident > 75) {
      result = "I know this! " + result;
    }

    return result;
  }
}
