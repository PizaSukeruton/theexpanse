// backend/traits/TraitManager.js

const pool = require('../db/pool');

/**
 * @module TraitManager
 * @description Manages character personality traits, including fetching and updating scores.
 * This module interacts with the 'character_trait_scores' table.
 */
class TraitManager {
    constructor() {
        console.log('TraitManager initialized.');
    }

    /**
     * Retrieves all trait scores for a given character.
     * @param {string} characterId - The hex ID of the character.
     * @returns {Promise<Object>} - An object mapping trait_hex_color to percentile_score (0-100).
     */
    async getCharacterTraitScores(characterId) {
        try {
            // Fetch trait scores from the database.
            const query = `
                SELECT trait_hex_color, percentile_score
                FROM character_trait_scores
                WHERE character_hex_id = $1;
            `;
            const res = await pool.query(query, [characterId]);
            const traitScores = {};
            res.rows.forEach(row => {
                traitScores[row.trait_hex_color] = row.percentile_score;
            });
            return traitScores;
        } catch (error) {
            console.error(`Error fetching trait scores for character ${characterId}:`, error);
            // Return empty scores to prevent blocking the application flow.
            return {};
        }
    }

    /**
     * Updates a specific trait score for a character.
     * This method would typically be called by the TSE learning loop.
     * @param {string} characterId - The hex ID of the character.
     * @param {string} traitHexId - The hex ID of the trait to update.
     * @param {number} delta - The amount to change the trait score by.
     * @returns {Promise<void>}
     */
    async updateTrait(characterId, traitHexId, delta) {
        try {
            console.log(`Attempting to update trait ${traitHexId} for character ${characterId} by delta ${delta}.`);

            // Example of what the actual DB interaction might look like:
            /*
            const currentScoreQuery = `SELECT percentile_score FROM character_trait_scores WHERE character_hex_id = $1 AND trait_hex_color = $2;`;
            const currentScoreRes = await pool.query(currentScoreQuery, [characterId, traitHexId]);
            let currentScore = currentScoreRes.rows[0] ? currentScoreRes.rows[0].percentile_score : 50; // Default if not found

            let newScore = Math.min(100, Math.max(0, currentScore + delta));

            const upsertQuery = `
                INSERT INTO character_trait_scores (character_hex_id, trait_hex_color, percentile_score)
                VALUES ($1, $2, $3)
                ON CONFLICT (character_hex_id, trait_hex_color) DO UPDATE SET percentile_score = EXCLUDED.percentile_score;
            `;
            await pool.query(upsertQuery, [characterId, traitHexId, newScore]);
            */
        } catch (error) {
            console.error(`Error updating trait ${traitHexId} for character ${characterId}:`, error);
        }
    }
}

module.exports = new TraitManager(); // Export a singleton instance
