import { ensureConcept } from "./helpers/ensureConcept.js";
import generateHexId from "../utils/hexIdGenerator.js";
import pool from "../db/pool.js";
import { embedText, cosineSimilarity } from "./helpers/semanticUtils.js";
import traitManager from "../traits/TraitManager.js";

export default class LearningDatabase {
  constructor(dbPool) {
    this.pool = dbPool;
  }

  async createCycle(acquired) {
    if (!acquired) throw new Error("createCycle: acquired payload missing");
    if (!acquired.characterId) throw new Error("createCycle: missing characterId");

    const characterId = acquired.characterId;
    const query = acquired.query || acquired.content;
    if (!query) throw new Error("createCycle: missing query/content");

    let rawConcept = acquired.concept || query;
    let safeConcept = "unknown";
    try {
      safeConcept = ensureConcept(rawConcept).substring(0, 40);
    } catch {
      safeConcept = rawConcept.substring(0, 40);
    }

    let embedding = null;
    try {
      embedding = await embedText(query);
    } catch {}

    const domainId = await this.detectDomain(query);
    const complexity = await this.computeComplexity(characterId, query);
    const knowledgeId = await generateHexId("knowledge_item_id");

    const sql = `
      INSERT INTO knowledge_items
        (knowledge_id, content, semantic_embedding, domain_id, source_type,
         initial_character_id, initial_strength, complexity_score, concept)
      VALUES ($1,$2,$3,$4,'tse_cycle',$5,1,$6,$7)
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      knowledgeId,
      query,
      embedding ? JSON.stringify(embedding) : null,
      domainId,
      characterId,
      complexity,
      safeConcept
    ]);

    return {
      status: "created",
      knowledge: result.rows[0],
      knowledge_id: knowledgeId
    };
  }

  // =========================================================
  // TSE LIFECYCLE RECORDS (CRITICAL FIX)
  // =========================================================

  async createTeacherRecord({
    cycleId,
    teacherSequence = 1,
    algorithmId,
    algorithmVersion,
    inputParameters = {}
  }) {
    const recordId = await generateHexId("tse_teacher_record_id");

    const sql = `
      INSERT INTO tse_teacher_records (
        record_id,
        cycle_id,
        teacher_sequence,
        algorithm_id,
        algorithm_version,
        input_parameters
      )
      VALUES ($1,$2,$3,$4,$5,$6)
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      recordId,
      cycleId,
      teacherSequence,
      algorithmId,
      algorithmVersion,
      JSON.stringify(inputParameters)
    ]);

    return result.rows[0];
  }

  async createStudentRecord({
    cycleId,
    teacherRecordId,
    studentSequence = 1
  }) {
    const recordId = await generateHexId("tse_student_record_id");

    const sql = `
      INSERT INTO tse_student_records (
        record_id,
        cycle_id,
        teacher_record_id,
        student_sequence
      )
      VALUES ($1,$2,$3,$4)
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      recordId,
      cycleId,
      teacherRecordId,
      studentSequence
    ]);

    return result.rows[0];
  }

  async computeComplexity(characterId, query) {
    try {
      const traits = await traitManager.getTraitVector(characterId);
      const inquisitive = traits["#00005A"] || 50;
      const overwhelmed = traits["#000012"] || 50;
      let complexity = 0.5 + (inquisitive - 50) * 0.005 - (overwhelmed - 50) * 0.003;
      return Math.max(0.1, Math.min(1.0, complexity));
    } catch {
      return 0.5;
    }
  }

  async detectDomain(query) {
    try {
      const rows = await this.pool.query(`
        SELECT domain_id FROM knowledge_domains WHERE is_active = TRUE
      `);
      return rows.rows[0]?.domain_id || "#00012C";
    } catch {
      return "#00012C";
    }
  }
  // ---------------------------------------------------------
  // TSE Cycle creation (authoritative lifecycle root)
  // ---------------------------------------------------------
  async createTseCycle(characterId, query, domainId = null) {
    const cycleId = await generateHexId("tse_cycle_id");

    const sql = `
      INSERT INTO tse_cycles (
        cycle_id,
        conversation_id,
        user_message,
        status,
        created_at
      )
      VALUES ($1, NULL, $2, 'running', NOW())
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      cycleId,
      query
    ]);

    return result.rows[0];
  }
}
