import padEstimator from './padEstimator.js';
import ngramSurprisal from './ngramSurprisal.js';
import metaphorDetector from './metaphorDetector.js';
import pool from '../db/pool.js';

class LearningDetector {
  async detectLearningOpportunity(message, userId) {
    const signals = {
      padNovelty: false,
      ngramNovelty: false,
      metaphorDetected: false,
      padSparse: false,
      lowCoverage: false,
      highSurprisal: false
    };
    
    let padResult;
    try {
      padResult = padEstimator.estimate(message);
    } catch (e) {
      padResult = {
        coverage: 0,
        novelty: null,
        pad: { pleasure: 0, arousal: 0, dominance: 0 },
        unknownWords: []
      };
    }
    signals.lowCoverage = padResult.coverage < 0.6;
    
    if (padResult.novelty === 'no_known_lexical_affect') {
      signals.padNovelty = true;
    }
    
    if (padResult.coverage > 0) {
      const nearby = await pool.query(`
        SELECT COUNT(*) as count
        FROM ltlm_training_examples 
        WHERE ABS(pad_pleasure - $1) < 0.25 
          AND ABS(pad_arousal - $2) < 0.25 
          AND ABS(pad_dominance - $3) < 0.25
      `, [padResult.pad.pleasure, padResult.pad.arousal, padResult.pad.dominance]);
      
      signals.padSparse = nearby.rows[0].count < 3;
    } else {
      signals.padSparse = false;
    }
    
    let surprisalResult;
    try {
      surprisalResult = ngramSurprisal.surprisal(message);
    } catch (e) {
      surprisalResult = {
        coverage: 1,
        score: 0,
        novelTrigrams: [],
        novelBigrams: []
      };
    }
    signals.ngramNovelty = surprisalResult.coverage < 0.5;
    signals.highSurprisal = surprisalResult.score > 6.0;
    
    let metaphorResult;
    try {
      metaphorResult = metaphorDetector.detect(message);
    } catch (e) {
      metaphorResult = {
        isMetaphor: false,
        confidence: 0
      };
    }
    signals.metaphorDetected = metaphorResult.isMetaphor;
    
    // --- Scalar learning pressure aggregation (Evaluator) ---
    const pressures = {
      padCoverage: Math.max(0, Math.min(1, 1 - padResult.coverage)),
      padNovelty: padResult.novelty === "no_known_lexical_affect" ? 1 : 0,
      padSparsity: signals.padSparse ? 1 : 0,
      ngramCoverage: Math.max(0, Math.min(1, 1 - surprisalResult.coverage)),
      surprisal: Math.max(0, Math.min(1, surprisalResult.score / 10)),
      metaphor: metaphorResult.isMetaphor ? (metaphorResult.confidence ?? 1) : 0
    };

    const weights = {
      padCoverage: 0.20,
      padNovelty: 0.15,
      padSparsity: 0.10,
      ngramCoverage: 0.20,
      surprisal: 0.20,
      metaphor: 0.15
    };

    const score = Object.keys(weights)
      .reduce((s, k) => s + weights[k] * pressures[k], 0);

    const shouldAsk = score >= 0.45;
    
    return {
      shouldAsk,
      signals,
      score,
      pressures,
      phrase: message,
      pad: padResult.pad,
      coverage: padResult.coverage,
      unknownWords: padResult.unknownWords,
      metaphor: metaphorResult.isMetaphor ? metaphorResult : undefined,
      novelNgrams: surprisalResult.novelTrigrams.concat(surprisalResult.novelBigrams).slice(0, 3),
      surprisalScore: surprisalResult.score,
      triggeredSignalNames: Object.keys(signals).filter(k => signals[k])
    };
  }
  
  getSignalExplanations(signals) {
    const explanations = [];
    
    if (signals.padNovelty) {
      explanations.push('no known emotional words');
    }
    if (signals.padSparse) {
      explanations.push('sparse emotional vocabulary');
    }
    if (signals.lowCoverage) {
      explanations.push('low lexical coverage');
    }
    if (signals.ngramNovelty) {
      explanations.push('novel word combinations');
    }
    if (signals.highSurprisal) {
      explanations.push('statistically unexpected phrasing');
    }
    if (signals.metaphorDetected) {
      explanations.push('figurative language detected');
    }
    
    return explanations;
  }
}

export default new LearningDetector();
