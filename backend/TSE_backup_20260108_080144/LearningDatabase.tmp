import { ensureConcept } from "./helpers/ensureConcept.js";
import generateHexId from "../utils/hexIdGenerator.js";
import pool from "../db/pool.js";
import { embedText } from "./helpers/semanticUtils.js";
import traitManager from "../traits/TraitManager.js";

export default class LearningDatabase {
  constructor(dbPool) {
    this.pool = dbPool || pool;
  }

  async saveTaskAttempt(attemptObj) {
    const { characterId, knowledgeId, taskId, score, attemptText, taskType = 'unknown', taskPhase = 'practice' } = attemptObj;
      embedding,
    const attemptId = await generateHexId("tse_attempt_id");

    const result = await this.pool.query(`
      INSERT INTO tse_task_attempts
        (attempt_id, task_id, character_id, knowledge_id, task_type, attempt_text, score, task_phase)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING id
    `, [attemptId, taskId, characterId, knowledgeId, taskType, attemptText, score, taskPhase]);

    return result.rows[0].id;
  }


  async getMasterySummary(characterId) {
    const result = await this.pool.query(`
      SELECT
        ta."knowledgeId",
        ki.domain_id AS domain,
        AVG(ta.score) AS avg_score,
        COUNT(*) AS attempt_count
      FROM tse_task_attempts ta
      LEFT JOIN knowledge_items ki
        ON ki.knowledge_id = ta."knowledgeId"
      WHERE ta."characterId" = $1
      GROUP BY ta."knowledgeId", ki.domain_id
    `, [characterId]);
    return result.rows;
  }


  async getRecentScores(characterId, limit = 10) {
    const result = await this.pool.query(`
      SELECT score, timestamp
      FROM tse_task_attempts
      WHERE "characterId" = $1
      ORDER BY timestamp DESC
      LIMIT $2
    `, [characterId, limit]);
    return result.rows;
  }


  async getDueItems(characterId, limit = 5) {
    const result = await this.pool.query(`
      SELECT ki.* FROM knowledge_items ki
      JOIN character_knowledge_state cks
        ON ki.knowledge_id = cks.knowledge_id
      WHERE cks.character_id = $1
        AND cks.next_review_timestamp <= NOW()
      ORDER BY cks.next_review_timestamp ASC
      LIMIT $2
    `, [characterId, limit]);
    return result.rows;
  }





  // ---------------------------------------------------------
  // KNOWLEDGE ITEM CREATION (legacy, untouched)
  // ---------------------------------------------------------
  async createCycle(acquired) {
    if (!acquired) throw new Error("createCycle: acquired payload missing");
    if (!acquired.characterId) throw new Error("createCycle: missing characterId");

    const characterId = acquired.characterId;
    const query = acquired.query || acquired.content;
    if (!query) throw new Error("createCycle: missing query/content");

    let rawConcept = acquired.concept || query;
    let safeConcept = "unknown";
    try {
      safeConcept = ensureConcept(rawConcept).substring(0, 40);
    } catch {
      safeConcept = rawConcept.substring(0, 40);
    }

    let embedding = null;
    try {
      embedding = await embedText(query);
    } catch {}

    const domainId = await this.detectDomain(query);
    const complexity = await this.computeComplexity(characterId, query);
    const knowledgeId = await generateHexId("knowledge_item_id");

    const sql = `
      INSERT INTO knowledge_items
        (knowledge_id, content, semantic_embedding, domain_id, source_type,
         initial_character_id, initial_strength, complexity_score, concept)
      VALUES ($1,$2,$3,$4,'tse_cycle',$5,1,$6,$7)
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      knowledgeId,
      query,
      embedding ? JSON.stringify(embedding) : null,
      domainId,
      characterId,
      complexity,
      safeConcept
    ]);

    return {
      status: "created",
      knowledge: result.rows[0],
      knowledge_id: knowledgeId
    };
  }

  // ---------------------------------------------------------
  // TSE CYCLE ROOT
  // ---------------------------------------------------------
  async createTseCycle(characterId, query, domainId = null) {
    const cycleId = await generateHexId("tse_cycle_id");

    const sql = `
      INSERT INTO tse_cycles (
        cycle_id,
        conversation_id,
        user_message,
        status,
        cycle_type,
        created_at
      )
      VALUES ($1, NULL, $2, 'running', 'standard', NOW())
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      cycleId,
      query
    ]);

    return result.rows[0];
  }

  // ---------------------------------------------------------
  // TEACHER / STUDENT RECORDS
  // ---------------------------------------------------------
  async createTeacherRecord({
    cycleId,
    teacherSequence = 1,
    algorithmId,
    algorithmVersion,
    inputParameters = {}
  }) {
    const recordId = await generateHexId("tse_teacher_record_id");

    const sql = `
      INSERT INTO tse_teacher_records (
        record_id,
        cycle_id,
        teacher_sequence,
        algorithm_id,
        algorithm_version,
        input_parameters
      )
      VALUES ($1,$2,$3,$4,$5,$6)
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      recordId,
      cycleId,
      teacherSequence,
      algorithmId,
      algorithmVersion,
      JSON.stringify(inputParameters)
    ]);

    return result.rows[0];
  }

  async createStudentRecord({
    cycleId,
    teacherRecordId,
    studentSequence = 1
  }) {
    const recordId = await generateHexId("tse_student_record_id");

    const sql = `
      INSERT INTO tse_student_records (
        record_id,
        cycle_id,
        teacher_record_id,
        student_sequence
      )
      VALUES ($1,$2,$3,$4)
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      recordId,
      cycleId,
      teacherRecordId,
      studentSequence
    ]);

    return result.rows[0];
  }

  // ---------------------------------------------------------
  // CYCLE COMPLETION (ONCE PER SESSION)
  // ---------------------------------------------------------
  async completeCycle({ cycleId, evaluations = [] }) {
    if (!cycleId) return null;

    const effectiveness =
      evaluations.length > 0
        ? evaluations.reduce((a, b) => a + (b.score || 0) / 5, 0) / evaluations.length
        : 0;

    const optimization =
      evaluations.length > 0
        ? evaluations.reduce(
            (a, b) => a + (b.communicationScores?.efficiency ?? 0.5),
            0
          ) / evaluations.length
        : 0.5;

    const sql = `
      UPDATE tse_cycles
      SET
        status = 'completed',
        completed_at = NOW(),
        learning_effectiveness = $1,
        optimization_score = $2,
        updated_at = NOW()
      WHERE cycle_id = $3
      RETURNING *;
    `;

    const result = await this.pool.query(sql, [
      effectiveness,
      optimization,
      cycleId
    ]);

    return result.rows[0];
  }

  // ---------------------------------------------------------
  // HELPERS
  // ---------------------------------------------------------
  async computeComplexity(characterId, query) {
    try {
      const traits = await traitManager.getTraitVector(characterId);
      const inquisitive = traits["#00005A"] || 50;
      const overwhelmed = traits["#000012"] || 50;
      let complexity = 0.5 + (inquisitive - 50) * 0.005 - (overwhelmed - 50) * 0.003;
      return Math.max(0.1, Math.min(1.0, complexity));
    } catch {
      return 0.5;
    }
  }

  async detectDomain(query) {
    try {
      const rows = await this.pool.query(`
        SELECT domain_id FROM knowledge_domains WHERE is_active = TRUE
      `);
      return rows.rows[0]?.domain_id || "#00012C";
    } catch {
      return "#00012C";
    }
  }
}
