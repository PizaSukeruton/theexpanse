import pool from "../db/pool.js";

export default class EvaluatorComponent {
  constructor() {
    this.now = () => new Date();
  }

  applyTraitModifiers(baseDifficulty, baseStability, traits) {
    let difficulty = baseDifficulty;
    let stability = baseStability;

    if (traits.curiosity_high) difficulty *= 0.90;
    if (traits.memory_strong) difficulty *= 0.95;
    if (traits.attention_sharp) difficulty *= 0.95;
    if (traits.chaos_inclined) difficulty *= 1.05;

    if (traits.determination_strong) stability *= 1.25;
    if (traits.long_term_thinker) stability *= 1.15;
    if (traits.discipline_high) stability *= 1.15;

    if (stability < 0.10) stability = 0.10;
    if (stability > 10.0) stability = 10.0;

    return { difficulty, stability };
  }

  computeRetrievability(stability, elapsedDays) {
    return Math.exp(-elapsedDays / stability);
  }

  computeNextInterval(stability, grade) {
    if (grade === 0) return 1;
    if (grade === 1) return Math.max(1, stability * 0.7);
    if (grade === 2) return Math.max(2, stability * 1.0);
    if (grade === 3) return Math.max(3, stability * 2.0);
    return 1;
  }

  async evaluateReview({ characterId, knowledgeId, grade, traits }) {
    const stateQuery = await pool.query(
      "SELECT * FROM character_knowledge_state WHERE characterId = $1 AND knowledgeId = $2",
      [characterId, knowledgeId]
    );

    let state = stateQuery.rows[0];

    if (!state) {
      state = {
        difficulty: 5.0,
        stability: 0.4,
        currentretrievability: 1.0,
        gradehistory: [],
        lastreviewtimestamp: this.now(),
        nextreviewtimestamp: this.now()
      };
    }

    const modified = this.applyTraitModifiers(
      state.difficulty,
      state.stability,
      traits || {}
    );

    const elapsedMs = this.now() - new Date(state.lastreviewtimestamp);
    const elapsedDays = elapsedMs / (1000 * 60 * 60 * 24);

    const retrievability = this.computeRetrievability(
      modified.stability,
      elapsedDays
    );

    const newInterval = this.computeNextInterval(modified.stability, grade);
    const nextReview = new Date(this.now().getTime() + newInterval * 86400000);

    const updatedDifficulty =
      grade === 3
        ? modified.difficulty * 0.97
        : grade === 2
        ? modified.difficulty * 1.0
        : modified.difficulty * 1.08;

    const updatedState = {
      difficulty: updatedDifficulty,
      stability: modified.stability,
      currentretrievability: retrievability,
      gradehistory: [...(state.gradehistory || []), grade],
      lastreviewtimestamp: this.now(),
      nextreviewtimestamp: nextReview
    };

    await pool.query(
      `INSERT INTO knowledge_review_logs
         (character_id, knowledge_id, reviewtimestamp, grade, previousinterval, newinterval)
       VALUES ($1, $2, NOW(), $3, $4, $5)`,
      [
        characterId,
        knowledgeId,
        grade,
        state.nextreviewtimestamp || this.now(),
        newInterval
      ]
    );

    await pool.query(
      `INSERT INTO character_knowledge_state
         (characterId, knowledgeId, difficulty, stability, currentretrievability,
          gradehistory, lastreviewtimestamp, nextreviewtimestamp)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
       ON CONFLICT (characterId, knowledgeId)
       DO UPDATE SET
         difficulty = EXCLUDED.difficulty,
         stability = EXCLUDED.stability,
         currentretrievability = EXCLUDED.currentretrievability,
         gradehistory = EXCLUDED.gradehistory,
         lastreviewtimestamp = EXCLUDED.lastreviewtimestamp,
         nextreviewtimestamp = EXCLUDED.nextreviewtimestamp`,
      [
        characterId,
        knowledgeId,
        updatedState.difficulty,
        updatedState.stability,
        updatedState.currentretrievability,
        JSON.stringify(updatedState.gradehistory),
        updatedState.lastreviewtimestamp,
        updatedState.nextreviewtimestamp
      ]
    );

    return {
      success: true,
      nextReview: updatedState.nextreviewtimestamp,
      updatedState
    };
  }
}
