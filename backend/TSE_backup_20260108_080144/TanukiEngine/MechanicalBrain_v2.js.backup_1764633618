import pool from "../../db/pool.js";
import generateHexId from "../../utils/hexIdGenerator.js";

import IntentDetector from "./IntentDetector.js";
import VocabularySelector from "./VocabularySelector.js";
import TanukiModeDetector from "./TanukiModeDetector.js";
import TanukiLevelSystem from "./TanukiLevelSystem.js";
import ForbiddenWordScrubber from "./ForbiddenWordScrubber.js";
import ResponseAssembler from "./ResponseAssembler.js";

export default class MechanicalBrain_v2 {
  constructor() {
    this.intentDetector = new IntentDetector();
    this.selector = new VocabularySelector();
    this.modeDetector = new TanukiModeDetector();
    this.levelSystem = new TanukiLevelSystem();
    this.scrubber = new ForbiddenWordScrubber();
    this.assembler = new ResponseAssembler();

    this.vocabCache = new Map();
    this.profileCache = new Map();
    this.CACHE_TTL_MS = 60000;
  }

  async loadVocabulary(characterId) {
    const cached = this.vocabCache.get(characterId);
    if (cached && cached.timestamp > Date.now() - this.CACHE_TTL_MS) {
      return cached.data;
    }

    const query = `
      SELECT vocabulary_json
      FROM learning_vocabulary
      WHERE character_id = $1
      LIMIT 1
    `;
    const result = await pool.query(query, [characterId]);
    if (result.rows.length === 0) return null;

    const vocab = result.rows[0].vocabulary_json;
    this.vocabCache.set(characterId, { data: vocab, timestamp: Date.now() });
    return vocab;
  }

  async loadProfile(characterId) {
    const cached = this.profileCache.get(characterId);
    if (cached && cached.timestamp > Date.now() - this.CACHE_TTL_MS) {
      return cached.data;
    }

    const query = `
      SELECT *
      FROM user_tanuki_profile
      WHERE character_id = $1
    `;
    let result = await pool.query(query, [characterId]);

    if (result.rows.length === 0) {
      const insertQuery = `
        INSERT INTO user_tanuki_profile 
          (character_id, current_tanuki_level, conversation_type_preferences, total_interactions, preferred_rabbit_holes, created_at, updated_at)
        VALUES ($1, 0.0, '{"factual":0,"playful":0,"philosophical":0}', 0, '{}', NOW(), NOW())
        RETURNING *
      `;
      result = await pool.query(insertQuery, [characterId]);
    }

    const profile = result.rows[0];
    this.profileCache.set(characterId, { data: profile, timestamp: Date.now() });
    return profile;
  }

  async logVocabularyUsage(characterId, vocabItem, category, intent, level, taskRef = null) {
    if (!vocabItem || !vocabItem.word) return;

    const usageId = await generateHexId("vocabulary_usage_id");

    const safeTaskRef =
      typeof taskRef === "string" && /^#[0-9A-F]{6}$/i.test(taskRef)
        ? taskRef
        : null;

    const query = `
      INSERT INTO vocabularyusagelogs
        (usageid, characterid, vocabword, vocabcategory, detectedintent, tanukilevel, taskreference)
      VALUES
        ($1, $2, $3, $4, $5, $6, $7)
    `;

    await pool.query(query, [
      usageId,
      characterId,
      vocabItem.word,
      category,
      intent,
      level,
      safeTaskRef
    ]);
  }

  async generateResponse(inputText, characterId, task, knowledgeId = null) {
    try {
      const vocab = await this.loadVocabulary(characterId);
      const profile = await this.loadProfile(characterId);

      if (!vocab) return "I do not understand this task yet.";

      const intent = this.intentDetector.detect(inputText);
      const baseLevel = Number(profile.current_tanuki_level || 0.0);

      const allTriggers = vocab.tanuki_mode_triggers || [];
      const overrides = profile.modeoverrides || null;

      const level = this.modeDetector.computeLevel(
        baseLevel,
        intent,
        allTriggers,
        inputText,
        overrides
      );

      const word1 = this.selector.getTanukiWord(vocab);
      const word2 = this.selector.getDefaultWord(vocab);

      if (word1)
        await this.logVocabularyUsage(
          characterId,
          word1,
          "tanuki_mode",
          intent,
          level,
          task?.taskId || null
        );

      if (word2)
        await this.logVocabularyUsage(
          characterId,
          word2,
          "default_vocabulary",
          intent,
          level,
          task?.taskId || null
        );

      const finalResponse = this.assembler.assemble(inputText, vocab, level);

      if (level !== baseLevel) {
        await this.levelSystem.updateLevel(
          characterId,
          baseLevel,
          level,
          "modeDetector"
        );
      }

      return finalResponse;
    } catch (err) {
      console.error("MechanicalBrain_v2 Error:", err.message);
      return "My thoughts shimmer too wildly to answer.";
    }
  }

  clearCache() {
    this.vocabCache.clear();
    this.profileCache.clear();
  }
}
