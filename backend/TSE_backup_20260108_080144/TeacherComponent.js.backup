import { TSE_CURRICULUM } from "./tse_curriculum.js";
import traitManager from "../traits/TraitManager.js"; 
import generateHexId from "../utils/hexIdGenerator.js";
import KnowledgeResponseEngine from "./helpers/KnowledgeResponseEngine.js";
import { getNaturalLanguageGenerator } from './helpers/NaturalLanguageGeneratorSingleton.js';
import pool from "../db/pool.js";

export default class TeacherComponent {
  constructor(learningDB) {
    console.trace('[TRACE] TeacherComponent.js constructed');
    this.learningDB = learningDB; 
   
    this.nodeId = Math.floor(Math.random() * 256)
      .toString(16)
      .toUpperCase()
      .padStart(2, "0");

    this.nlg = getNaturalLanguageGenerator();
    this.responseEngine = new KnowledgeResponseEngine();
  }

  async initialize() {
    return true;
  }

  getNodeId() {
    return this.nodeId;
  }

  async teach(characterId, query, context) {
    const baseDifficulty = await this._computeTraitDifficulty(characterId);
    const difficulty = await this._applyAdaptiveDifficulty(characterId, baseDifficulty);

    let task = null;

    // COMMUNICATION TASK SELECTOR
    if (query && query.toLowerCase().includes('communication')) {
      const commTasks = TSE_CURRICULUM.filter(t => t.taskType === 'communication_quality');
      if (commTasks.length > 0) {
        const selected = commTasks[Math.floor(Math.random() * commTasks.length)];
        const taskId = await generateHexId("tse_task_id");
        
        task = {
          taskId,
          taskType: selected.taskType,
          instructions: selected.instructions,
          input: selected.input,
          expectedFormat: selected.expectedFormat,
          difficulty: selected.difficulty,
          characterId,
          metadata: {
            ...selected.metadata,
            teacherNode: this.nodeId,
            difficulty: selected.difficulty,
            context
          }
        };
        return task;
      }
    }

    if (query && (query.toLowerCase().includes('piza') || query.toLowerCase().includes('expanse'))) {
      task = await this._teachLoreFact(characterId, query, difficulty);
    }
    if (!task) {
      const candidates = TSE_CURRICULUM.filter((t) => t.difficulty === difficulty);
      const selectedCandidates = candidates.length > 0 ? candidates : TSE_CURRICULUM;
      const selected = selectedCandidates[Math.floor(Math.random() * selectedCandidates.length)];

      const taskId = await generateHexId("tse_task_id");

      task = {
        taskId,
        taskType: selected.taskType,
        instructions: selected.instructions,
        input: selected.input,
        expectedFormat: selected.expectedFormat,
        difficulty,
        characterId,
        metadata: {
          teacherNode: this.nodeId,
          difficulty,
          traitDifficulty: baseDifficulty,
          context
        }
      };
    }

    return task;
  }

  async _teachLoreFact(characterId, query, difficulty) {
    try {
      const result = await pool.query(`
        SELECT k.knowledge_id, k.content
        FROM knowledge_items k
        WHERE k.source_type = 'admin_entry'
        AND (
          k.content::text ILIKE $1 
          OR k.content::text ILIKE $2
        )
        LIMIT 1
      `, [`%${query}%`, '%piza%']);

      if (result.rows.length === 0) {
        console.log("[TeacherComponent] No lore facts found for query:", query);
        return null;
      }

      const fact = result.rows[0];
      const content = typeof fact.content === 'string' ? JSON.parse(fact.content) : fact.content;

      const taskId = await generateHexId("tse_task_id");

      console.log("[TeacherComponent] Teaching lore fact:", fact.knowledge_id);

      return {
        taskId,
        taskType: "lore_comprehension",
        instructions: `Answer this lore question based on your knowledge of the Piza Sukeruton Multiverse:`,
        input: `Question: ${content.statement}`,
        expectedFormat: "Provide a thoughtful answer connecting this fact to the broader multiverse.",
        difficulty: content.difficulty === 'hard' ? 3 : content.difficulty === 'medium' ? 2 : 1,
        characterId,
        knowledgeId: fact.knowledge_id,
        canonicalAnswer: content.statement,
        metadata: {
          teacherNode: this.nodeId,
          difficulty,
          taskType: "lore_comprehension",
          sourceKnowledge: fact.knowledge_id
        }
      };
    } catch (err) {
      console.error("[TeacherComponent] Lore query failed:", err.message);
      return null;
    }
  }

  async _computeTraitDifficulty(characterId) {
    try {
      const traits = await traitManager.getTraitVector(characterId);
      if (traits && traits.intelligence) {
        return Math.max(1, Math.min(5, Math.ceil(traits.intelligence / 20)));
      }
    } catch (err) {
      console.warn("[TeacherComponent] Trait lookup failed:", err.message);
    }
    return 2;
  }

  async _applyAdaptiveDifficulty(characterId, baseDifficulty) {
    try {
      if (this.learningDB && this.learningDB.pool) {
        const result = await this.learningDB.pool.query(
          `SELECT AVG(CAST(score AS NUMERIC)) as avgPerf FROM tse_task_attempts 
           WHERE character_id = $1 LIMIT 10`,
          [characterId]
        );
        const avgPerf = result.rows[0]?.avgperf || 0.5;
        if (avgPerf > 0.7) return Math.min(5, baseDifficulty + 1);
        if (avgPerf < 0.3) return Math.max(1, baseDifficulty - 1);
      }
    } catch (err) {
      console.warn("[TeacherComponent] Adaptive difficulty failed:", err.message);
    }
    return baseDifficulty;
  }

  async generateFollowUpTask(previousTask, evaluation) {
    if (evaluation.score >= 4) {
      return null;
    }
    return {
      taskId: await generateHexId("tse_task_id"),
      taskType: "clarification",
      instructions: "Let's revisit this. Can you expand on your answer?",
      input: previousTask.input,
      expectedFormat: "More detailed explanation",
      difficulty: previousTask.difficulty,
      metadata: {
        chainFrom: previousTask.taskId,
        feedback: evaluation.feedback
      }
    };
  }
}
