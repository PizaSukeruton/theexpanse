<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Psych State Radar Console</title>
  <style>
    :root {
      --crt-green: #00ff7f;
      --crt-dark: #020805;
      --console-bg: #050a08;
      --console-edge: #1c3026;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: radial-gradient(circle at top, #04110a 0, #000 55%, #000 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Mono",
        "IBM Plex Mono", monospace;
      color: var(--crt-green);
      overflow: hidden;
    }

    /* CRT container */
    .crt-wrapper {
      position: relative;
      width: min(900px, 95vw);
      aspect-ratio: 16 / 9;
      background: #000;
      padding: 16px;
      box-shadow:
        0 0 25px rgba(0, 0, 0, 0.9),
        0 0 120px rgba(0, 0, 0, 1);
      border-radius: 8px;
      overflow: hidden;
    }

    /* Scanlines + glow */
    .crt-wrapper::before {
      content: "";
      pointer-events: none;
      position: absolute;
      inset: 0;
      background-image: linear-gradient(
        rgba(0, 0, 0, 0.35) 1px,
        transparent 1px
      );
      background-size: 100% 2px;
      mix-blend-mode: multiply;
      opacity: 0.65;
      z-index: 4;
    }

    .crt-wrapper::after {
      content: "";
      pointer-events: none;
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center, rgba(0, 255, 127, 0.22), transparent 60%);
      opacity: 0.8;
      mix-blend-mode: screen;
      z-index: 3;
    }

    .crt-flicker {
      animation: crt-flicker 2.2s infinite steps(1, end);
    }

    @keyframes crt-flicker {
      0%   { opacity: 1;   }
      3%   { opacity: 0.92;}
      5%   { opacity: 1;   }
      15%  { opacity: 0.96;}
      16%  { opacity: 1;   }
      28%  { opacity: 0.94;}
      29%  { opacity: 1;   }
      60%  { opacity: 0.98;}
      61%  { opacity: 1;   }
      100% { opacity: 1;   }
    }

    /* Console panel */
    .console {
      position: relative;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #101b15 0, #050a08 55%, #020504 100%);
      border-radius: 6px;
      border: 2px solid var(--console-edge);
      padding: 18px 22px;
      display: grid;
      grid-template-columns: 1fr 260px;
      grid-template-rows: 1fr auto;
      column-gap: 18px;
      row-gap: 10px;
      box-shadow:
        inset 0 0 25px rgba(0, 0, 0, 0.8),
        0 0 40px rgba(0, 0, 0, 0.9);
    }

    /* Left column container */
    .left-column {
      grid-row: 1 / 3;
      grid-column: 1 / 2;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Radar bezel */
    .radar-bezel {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .radar-frame {
      position: relative;
      width: 100%;
      max-width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 50%;
      padding: 18px;
      background: radial-gradient(circle at 30% 0, #273a30, #0a1410 60%, #000 100%);
      box-shadow:
        inset 0 0 45px rgba(0, 0, 0, 1),
        0 0 35px rgba(0, 0, 0, 0.8);
      border: 4px solid #1d2a22;
    }

    .radar-frame::before {
      content: "";
      position: absolute;
      inset: 8px;
      border-radius: 50%;
      border: 3px solid rgba(0, 255, 127, 0.08);
      box-shadow: 0 0 20px rgba(0, 255, 127, 0.18);
      pointer-events: none;
    }

    .radar-glass {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      overflow: hidden;
      background: radial-gradient(circle at 50% 30%, #102211 0, #050908 60%, #020403 100%);
      box-shadow:
        inset 0 0 80px rgba(0, 0, 0, 0.9),
        0 0 50px rgba(0, 255, 127, 0.25);
      cursor: crosshair;
    }

    #radarCanvas {
      width: 100%;
      height: 100%;
      display: block;
      filter: blur(0.4px) saturate(1.2);
    }

    /* Subtle reflection streak */
    .radar-glass::after {
      content: "";
      position: absolute;
      left: -5%;
      top: -15%;
      width: 60%;
      height: 60%;
      background: radial-gradient(circle at 30% 0,
          rgba(255, 255, 255, 0.22),
          transparent 60%);
      opacity: 0.35;
      mix-blend-mode: screen;
      transform: rotate(-8deg);
      pointer-events: none;
    }

    /* Data readout panel */
    .data-panel {
      border-radius: 4px;
      border: 1px solid #102019;
      background: linear-gradient(to bottom, #050b08, #0b1510);
      padding: 10px 14px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 16px;
      font-family: "SF Mono", "IBM Plex Mono", monospace;
      font-size: 11px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.8);
    }

    .data-field {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .data-label {
      color: rgba(0, 255, 127, 0.5);
      text-shadow: 0 0 2px rgba(0, 255, 127, 0.4);
    }

    .data-value {
      color: var(--crt-green);
      text-shadow:
        0 0 3px rgba(0, 255, 127, 0.8),
        0 0 6px rgba(0, 255, 127, 0.6);
      font-weight: 600;
    }

    .data-field.full-width {
      grid-column: 1 / 3;
    }

    .signal-bar {
      display: flex;
      gap: 2px;
      align-items: flex-end;
      height: 12px;
    }

    .signal-bar span {
      width: 6px;
      background: rgba(0, 255, 127, 0.2);
      border: 1px solid rgba(0, 255, 127, 0.3);
      transition: background 0.2s ease;
    }

    .signal-bar span.active {
      background: rgba(0, 255, 127, 0.9);
      border-color: rgba(0, 255, 127, 1);
      box-shadow: 0 0 4px rgba(0, 255, 127, 0.8);
    }

    /* Manufacturer badge */
    .manufacturer-badge {
      position: absolute;
      bottom: 8px;
      right: 12px;
      font-size: 9px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(0, 255, 127, 0.35);
      text-shadow: 0 0 2px rgba(0, 255, 127, 0.2);
      opacity: 0.5;
      font-family: "SF Mono", monospace;
      z-index: 10;
    }

    /* Right-side control field */
    .controls {
      grid-column: 2 / 3;
      grid-row: 1 / 3;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
    }

    .controls-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .controls-row.center {
      justify-content: center;
      flex-wrap: wrap;
      row-gap: 14px;
    }

    /* Button styles */
    .round-button {
      position: relative;
      width: 46px;
      height: 46px;
      border-radius: 50%;
      border: 2px solid #1d3124;
      background: radial-gradient(circle at 30% 30%, #152018, #050806 65%, #000 100%);
      box-shadow:
        0 0 12px rgba(0, 0, 0, 0.9),
        inset 0 0 10px rgba(0, 0, 0, 0.9);
      cursor: pointer;
      outline: none;
      transition:
        transform 80ms ease-out,
        box-shadow 80ms ease-out,
        border-color 100ms ease-out;
    }

    .round-button::before {
      content: "";
      position: absolute;
      inset: 5px;
      border-radius: 50%;
      background: radial-gradient(circle at 25% 20%, #1a2a1f, #030604 70%);
      box-shadow: 0 0 14px rgba(0, 255, 127, 0.12);
    }

    .round-button::after {
      content: "";
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(0, 255, 127, 0.0);
      top: 7px;
      right: 10px;
      box-shadow: 0 0 0 rgba(0, 255, 127, 0);
      transition: background 120ms ease-out, box-shadow 120ms ease-out;
    }

    .round-button:hover {
      transform: translateY(-1px);
      border-color: #2a5039;
      box-shadow:
        0 0 16px rgba(0, 0, 0, 1),
        0 0 10px rgba(0, 255, 127, 0.2);
    }

    .round-button:active {
      transform: translateY(1px) scale(0.97);
      box-shadow:
        0 0 8px rgba(0, 0, 0, 1),
        0 0 6px rgba(0, 255, 127, 0.2);
    }

    .round-button.active::after {
      background: rgba(0, 255, 127, 0.9);
      box-shadow: 0 0 14px rgba(0, 255, 127, 0.8);
    }

    .mini-toggle {
      width: 38px;
      height: 38px;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(5, 10, 8, 0.95);
      border: 1px solid rgba(0, 255, 127, 0.4);
      border-radius: 4px;
      padding: 6px 10px;
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--crt-green);
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 100;
      box-shadow: 0 0 12px rgba(0, 255, 127, 0.3);
      text-shadow: 0 0 4px rgba(0, 255, 127, 0.6);
    }

    .round-button:hover .tooltip {
      opacity: 1;
    }

    /* Status band */
    .status-band {
      align-self: center;
      justify-self: stretch;
      border-radius: 4px;
      border: 1px solid #102019;
      background: linear-gradient(to right, #050b08, #0b1510);
      padding: 6px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 11px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      opacity: 0.9;
    }

    .status-band span {
      opacity: 0.8;
      text-shadow:
        0 0 3px rgba(0, 255, 127, 0.8),
        0 0 6px rgba(0, 255, 127, 0.6);
    }

    .status-band .status-bar {
      position: relative;
      flex: 1;
      height: 4px;
      margin-left: 6px;
      border-radius: 999px;
      background: linear-gradient(
        to right,
        rgba(0, 70, 40, 1),
        rgba(0, 120, 80, 1),
        rgba(0, 255, 127, 0.9)
      );
      overflow: hidden;
    }

    .status-band .status-meter {
      position: absolute;
      inset: 0;
      transform-origin: left center;
      background: linear-gradient(
        to right,
        rgba(0, 255, 127, 0),
        rgba(0, 255, 127, 0.6),
        rgba(0, 255, 127, 0.9)
      );
      box-shadow:
        0 0 6px rgba(0, 255, 127, 0.9),
        0 0 12px rgba(0, 255, 127, 0.9);
      transform: scaleX(0.4);
      transition: transform 0.3s ease;
    }

    /* Vignette */
    .vignette {
      pointer-events: none;
      position: absolute;
      inset: 0;
      box-shadow: inset 0 0 120px rgba(0, 0, 0, 0.95);
      z-index: 5;
    }

    /* Keyboard shortcut hint */
    .keyboard-hint {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 9px;
      color: rgba(0, 255, 127, 0.3);
      text-shadow: 0 0 2px rgba(0, 255, 127, 0.2);
      z-index: 10;
      opacity: 0.6;
      transition: opacity 0.3s ease;
    }

    .keyboard-hint:hover {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="crt-wrapper crt-flicker">
    <div class="console">
      <div class="left-column">
        <div class="radar-bezel">
          <div class="radar-frame">
            <div class="radar-glass">
              <canvas id="radarCanvas"></canvas>
            </div>
          </div>
        </div>
        
        <div class="data-panel">
          <div class="data-field">
            <span class="data-label">Bearing</span>
            <span class="data-value" id="bearingValue">---°</span>
          </div>
          <div class="data-field">
            <span class="data-label">Range</span>
            <span class="data-value" id="rangeValue">-.-- km</span>
          </div>
          <div class="data-field full-width">
            <span class="data-label">Signal</span>
            <div class="signal-bar" id="signalBar">
              <span style="height: 30%"></span>
              <span style="height: 45%"></span>
              <span style="height: 60%"></span>
              <span style="height: 75%"></span>
              <span style="height: 90%"></span>
              <span style="height: 100%"></span>
              <span style="height: 90%"></span>
              <span style="height: 75%"></span>
            </div>
          </div>
          <div class="data-field">
            <span class="data-label">Time</span>
            <span class="data-value" id="timeValue">--:--:--</span>
          </div>
          <div class="data-field">
            <span class="data-label">Entities</span>
            <span class="data-value" id="entitiesValue">30</span>
          </div>
        </div>
      </div>

      <div class="controls">
        <div class="controls-row">
          <button class="round-button" data-action="mode-alpha" aria-label="Mode Alpha">
            <span class="tooltip">Alpha Mode</span>
          </button>
          <button class="round-button" data-action="mode-beta" aria-label="Mode Beta">
            <span class="tooltip">Beta Mode</span>
          </button>
          <button class="round-button" data-action="mode-gamma" aria-label="Mode Gamma">
            <span class="tooltip">Gamma Mode</span>
          </button>
        </div>

        <div class="controls-row center">
          <button class="round-button" data-action="pulse" aria-label="Impulse Ping">
            <span class="tooltip">Impulse Ping</span>
          </button>
          <button class="round-button" data-action="lock-target" aria-label="Lock Character">
            <span class="tooltip">Lock Target</span>
          </button>
          <button class="round-button" data-action="noise" aria-label="Toggle Noise">
            <span class="tooltip">Toggle Static</span>
          </button>
        </div>

        <div class="controls-row">
          <button class="round-button mini-toggle" data-action="freeze" aria-label="Freeze Sweep">
            <span class="tooltip">Freeze Sweep</span>
          </button>
          <button class="round-button mini-toggle" data-action="density" aria-label="Adjust Density">
            <span class="tooltip">Adjust Density</span>
          </button>
        </div>

        <div class="status-band">
          <span>◦ ◦ ◦</span>
          <div class="status-bar">
            <div class="status-meter" id="statusMeter"></div>
          </div>
          <span>◎</span>
        </div>
      </div>
      
      <div class="manufacturer-badge">PSI SYSTEMS • MODEL RC-7 • EST. 1957</div>
    </div>
    <div class="vignette"></div>
    <div class="keyboard-hint">Press M for modes • P for pulse • L to lock • N for noise • F to freeze • D for density • ESC to reset</div>
  </div>

  <script>
    // --- RADAR SETUP -------------------------------------------------------
    const canvas = document.getElementById("radarCanvas");
    const ctx = canvas.getContext("2d");
    let width, height, centerX, centerY, radius;

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const size = Math.min(rect.width, rect.height);
      canvas.width = size * window.devicePixelRatio;
      canvas.height = size * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);

      width = size;
      height = size;
      centerX = width / 2;
      centerY = height / 2;
      radius = size * 0.47;
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // --- STATE -------------------------------------------------------------
    let sweepAngle = 0;
    let lastTime = 0;
    let frozen = false;
    let noiseOn = false;
    let densityLevel = 0.7;
    let activeMode = "alpha";
    let pulsePhase = 0;
    let lockTargetIndex = null;

    const statusMeter = document.getElementById("statusMeter");

    // Blips array - populated by live data
    // Expected format: { r: number, theta: number, intensity: number, phase: number, id: string, data: object }
    let blips = [];

    function updateStatusMeter() {
      const base =
        activeMode === "alpha"
          ? 0.35
          : activeMode === "beta"
          ? 0.6
          : 0.8;
      const noise = (Math.random() - 0.5) * 0.15;
      const value = Math.max(0.15, Math.min(1, base + noise));
      statusMeter.style.transform = `scaleX(${value})`;
    }

    // --- DATA PANEL UPDATES ------------------------------------------------
    function updateDataPanel() {
      // Update time
      const now = new Date();
      const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
      document.getElementById('timeValue').textContent = timeStr;

      // Update based on locked target or sweep position
      if (lockTargetIndex !== null) {
        const blip = blips[lockTargetIndex];
        const bearing = Math.round((blip.theta * 180 / Math.PI + 360) % 360);
        const range = (blip.r / radius * 4).toFixed(2);
        
        document.getElementById('bearingValue').textContent = `${bearing}°`;
        document.getElementById('rangeValue').textContent = `${range} km`;
        
        // Update signal bars based on blip intensity
        const signalBars = document.querySelectorAll('#signalBar span');
        const activeCount = Math.floor(blip.intensity * 8);
        signalBars.forEach((bar, i) => {
          bar.classList.toggle('active', i < activeCount);
        });
      } else {
        // Show sweep position
        const bearing = Math.round((sweepAngle * 180 / Math.PI + 360) % 360);
        document.getElementById('bearingValue').textContent = `${bearing}°`;
        document.getElementById('rangeValue').textContent = '-.-- km';
        
        // Dim signal bars
        const signalBars = document.querySelectorAll('#signalBar span');
        const activeCount = Math.floor(Math.random() * 3);
        signalBars.forEach((bar, i) => {
          bar.classList.toggle('active', i < activeCount);
        });
      }
    }

    // --- DRAWING HELPERS ---------------------------------------------------
    function drawRadarBackground() {
      ctx.save();
      ctx.clearRect(0, 0, width, height);

      // Mask circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.clip();

      // Base glow
      const g = ctx.createRadialGradient(
        centerX,
        centerY,
        radius * 0.1,
        centerX,
        centerY,
        radius
      );
      g.addColorStop(0, "rgba(0, 40, 16, 1)");
      g.addColorStop(0.4, "rgba(0, 24, 10, 1)");
      g.addColorStop(1, "rgba(0, 6, 3, 1)");
      ctx.fillStyle = g;
      ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);

      // Concentric range rings with labels
      ctx.lineWidth = 1;
      ctx.font = '10px SF Mono, monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      for (let i = 1; i <= 4; i++) {
        const r = (radius / 4) * i;
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
        const alpha = 0.12 + i * 0.02;
        ctx.strokeStyle = `rgba(0, 255, 127, ${alpha})`;
        ctx.stroke();
        
        // Add range label at top
        ctx.fillStyle = `rgba(0, 255, 127, ${alpha + 0.1})`;
        ctx.fillText(`${i}km`, centerX, centerY - r + 8);
      }

      // Crosshair
      ctx.strokeStyle = "rgba(0,255,127,0.25)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(centerX - radius, centerY);
      ctx.lineTo(centerX + radius, centerY);
      ctx.moveTo(centerX, centerY - radius);
      ctx.lineTo(centerX, centerY + radius);
      ctx.stroke();
      
      // Degree markers
      ctx.font = '9px SF Mono, monospace';
      ctx.fillStyle = 'rgba(0, 255, 127, 0.3)';
      const degrees = [0, 90, 180, 270];
      const labels = ['0°', '90°', '180°', '270°'];
      degrees.forEach((deg, idx) => {
        const rad = (deg - 90) * Math.PI / 180;
        const x = centerX + Math.cos(rad) * (radius + 12);
        const y = centerY + Math.sin(rad) * (radius + 12);
        ctx.fillText(labels[idx], x, y);
      });

      ctx.restore();
    }

    function drawSweep(deltaSeconds) {
      if (!frozen) {
        const speed =
          activeMode === "alpha"
            ? 0.45
            : activeMode === "beta"
            ? 0.75
            : 1.1;
        sweepAngle += deltaSeconds * speed * Math.PI * 2;
      }

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.translate(centerX, centerY);

      // trailing wedge
      const sweepWidth = Math.PI / 32;
      const startAngle = sweepAngle - sweepWidth * 1.8;

      const grad = ctx.createRadialGradient(0, 0, radius * 0.05, 0, 0, radius);
      const baseIntensity =
        activeMode === "alpha"
          ? 0.8
          : activeMode === "beta"
          ? 1.0
          : 1.2;
      grad.addColorStop(
        0,
        `rgba(0,255,127,${0.14 * baseIntensity})`
      );
      grad.addColorStop(
        0.7,
        `rgba(0,255,127,${0.04 * baseIntensity})`
      );
      grad.addColorStop(1, "rgba(0,255,127,0)");

      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, startAngle, sweepAngle);
      ctx.closePath();
      ctx.fill();

      // bright leading line
      ctx.rotate(sweepAngle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(radius, 0);
      ctx.lineWidth = 2.1;
      ctx.strokeStyle = "rgba(0,255,127,0.95)";
      ctx.shadowColor = "rgba(0,255,127,1)";
      ctx.shadowBlur = 18;
      ctx.stroke();

      ctx.restore();
    }

    function drawBlips(time) {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.globalCompositeOperation = "lighter";

      const sweepWindow = Math.PI / 16;
      const now = time / 1000;

      blips.forEach((b, index) => {
        const angleDiff = Math.atan2(Math.sin(b.theta - sweepAngle), Math.cos(b.theta - sweepAngle));
        const closeToSweep = Math.abs(angleDiff) < sweepWindow;

        // twinkle intensity
        const twinkle = 0.5 + 0.5 * Math.sin(now * 4 + b.phase);
        let alpha = b.intensity * twinkle * densityLevel;

        if (!closeToSweep) {
          alpha *= 0.25;
        }

        if (lockTargetIndex === index) {
          alpha *= 1.6;
        }

        const x = Math.cos(b.theta) * b.r;
        const y = Math.sin(b.theta) * b.r;

        // aura
        const grd = ctx.createRadialGradient(x, y, 0, x, y, 12);
        grd.addColorStop(0, `rgba(0,255,140,${alpha})`);
        grd.addColorStop(0.7, `rgba(0,255,127,${alpha * 0.45})`);
        grd.addColorStop(1, "rgba(0,0,0,0)");

        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.fill();

        // core point
        ctx.beginPath();
        ctx.arc(x, y, 2.2, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0,255,180,${Math.min(1, alpha * 1.9)})`;
        ctx.fill();
      });

      ctx.restore();
    }

    function drawPulseOverlay(deltaSeconds) {
      if (pulsePhase <= 0) return;
      pulsePhase -= deltaSeconds * 1.4;
      if (pulsePhase < 0) pulsePhase = 0;

      const t = pulsePhase;
      const maxR = radius * (1.1 + 0.4 * (1 - t));

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.globalCompositeOperation = "lighter";

      const rings = 3;
      for (let i = 0; i < rings; i++) {
        const frac = (i + t) / rings;
        const r = maxR * frac;
        if (r <= 0) continue;
        const alpha = 0.35 * (1 - frac);
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(0,255,127,${alpha})`;
        ctx.lineWidth = 1.8;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawNoise() {
      if (!noiseOn) return;
      const chance = 0.16;
      if (Math.random() > chance) return;

      const grains = 150;
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (let i = 0; i < grains; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * radius;
        const x = centerX + Math.cos(a) * r;
        const y = centerY + Math.sin(a) * r;
        const alpha = Math.random() * 0.2;
        ctx.fillStyle = `rgba(0,255,127,${alpha})`;
        ctx.fillRect(x, y, 1, 1);
      }
      ctx.restore();
    }

    // --- CANVAS CLICK TO LOCK BLIP -----------------------------------------
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const clickX = (e.clientX - rect.left) * (width / rect.width);
      const clickY = (e.clientY - rect.top) * (height / rect.height);
      
      // Convert to polar coordinates relative to center
      const dx = clickX - centerX;
      const dy = clickY - centerY;
      const clickR = Math.sqrt(dx * dx + dy * dy);
      const clickTheta = Math.atan2(dy, dx);
      
      // Check if click is near any blip
      let foundBlip = null;
      let minDist = 15; // Click tolerance in pixels
      
      blips.forEach((b, index) => {
        const blipX = Math.cos(b.theta) * b.r;
        const blipY = Math.sin(b.theta) * b.r;
        const dist = Math.sqrt((dx - blipX) ** 2 + (dy - blipY) ** 2);
        
        if (dist < minDist) {
          minDist = dist;
          foundBlip = index;
        }
      });
      
      if (foundBlip !== null) {
        if (lockTargetIndex === foundBlip) {
          // Unlock if clicking same blip
          lockTargetIndex = null;
          document.querySelector('[data-action="lock-target"]').classList.remove('active');
        } else {
          // Lock new blip
          lockTargetIndex = foundBlip;
          document.querySelector('[data-action="lock-target"]').classList.add('active');
        }
      }
    });

    // --- MAIN LOOP ---------------------------------------------------------
    function loop(timestamp) {
      const delta = (timestamp - lastTime) / 1000 || 0.016;
      lastTime = timestamp;

      drawRadarBackground();
      drawBlips(timestamp);
      drawSweep(delta);
      drawPulseOverlay(delta);
      drawNoise();
      updateStatusMeter();
      updateDataPanel();

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

    // --- BUTTON LOGIC ------------------------------------------------------
    const buttons = document.querySelectorAll(".round-button");
    buttons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const action = btn.dataset.action;
        handleAction(action, btn);
      });
    });

    function clearModeButtons() {
      document
        .querySelectorAll('[data-action^="mode-"]')
        .forEach((b) => b.classList.remove("active"));
    }

    function handleAction(action, btn) {
      switch (action) {
        case "mode-alpha":
          activeMode = "alpha";
          clearModeButtons();
          btn.classList.add("active");
          break;
        case "mode-beta":
          activeMode = "beta";
          clearModeButtons();
          btn.classList.add("active");
          break;
        case "mode-gamma":
          activeMode = "gamma";
          clearModeButtons();
          btn.classList.add("active");
          break;
        case "pulse":
          pulsePhase = 1.0;
          btn.classList.add("active");
          setTimeout(() => btn.classList.remove("active"), 180);
          break;
        case "lock-target":
          // Lock/unlock controlled externally or via click
          // Use lockTargetIndex to track locked blip
          if (lockTargetIndex !== null) {
            lockTargetIndex = null;
            btn.classList.remove("active");
          }
          // Note: To lock a target, set lockTargetIndex to blip index or use canvas click
          break;
        case "noise":
          noiseOn = !noiseOn;
          btn.classList.toggle("active", noiseOn);
          break;
        case "freeze":
          frozen = !frozen;
          btn.classList.toggle("active", frozen);
          break;
        case "density":
          if (densityLevel < 0.4) densityLevel = 0.7;
          else if (densityLevel < 0.8) densityLevel = 1.0;
          else densityLevel = 0.25;
          btn.classList.add("active");
          setTimeout(() => btn.classList.remove("active"), 160);
          break;
        default:
          break;
      }
    }

    // --- KEYBOARD SHORTCUTS ------------------------------------------------
    document.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      
      switch(key) {
        case 'm':
          // Cycle modes
          if (activeMode === 'alpha') {
            handleAction('mode-beta', document.querySelector('[data-action="mode-beta"]'));
          } else if (activeMode === 'beta') {
            handleAction('mode-gamma', document.querySelector('[data-action="mode-gamma"]'));
          } else {
            handleAction('mode-alpha', document.querySelector('[data-action="mode-alpha"]'));
          }
          break;
        case 'p':
          handleAction('pulse', document.querySelector('[data-action="pulse"]'));
          break;
        case 'l':
          handleAction('lock-target', document.querySelector('[data-action="lock-target"]'));
          break;
        case 'n':
          handleAction('noise', document.querySelector('[data-action="noise"]'));
          break;
        case 'f':
          handleAction('freeze', document.querySelector('[data-action="freeze"]'));
          break;
        case 'd':
          handleAction('density', document.querySelector('[data-action="density"]'));
          break;
        case '1':
          handleAction('mode-alpha', document.querySelector('[data-action="mode-alpha"]'));
          break;
        case '2':
          handleAction('mode-beta', document.querySelector('[data-action="mode-beta"]'));
          break;
        case '3':
          handleAction('mode-gamma', document.querySelector('[data-action="mode-gamma"]'));
          break;
        case 'escape':
          // Reset all
          lockTargetIndex = null;
          frozen = false;
          noiseOn = false;
          densityLevel = 0.7;
          activeMode = 'alpha';
          clearModeButtons();
          document.querySelector('[data-action="mode-alpha"]').classList.add('active');
          document.querySelector('[data-action="lock-target"]').classList.remove('active');
          document.querySelector('[data-action="noise"]').classList.remove('active');
          document.querySelector('[data-action="freeze"]').classList.remove('active');
          break;
      }
    });

    // Initialize defaults
    document.querySelector('[data-action="mode-alpha"]').classList.add("active");

    // ========================================================================
    // PUBLIC API FOR LIVE DATA INTEGRATION
    // ========================================================================
    
    window.PsychicRadar = {
      // Update blips with live data
      // data: Array of { r, theta, intensity, phase, id, entityData }
      // r: radius from center (0 to radius)
      // theta: angle in radians (0 to 2π)
      // intensity: 0 to 1
      // phase: offset for twinkling (0 to 2π)
      // id: unique identifier for the blip
      // entityData: optional object with entity details
      updateBlips: function(data) {
        blips = data.map(b => ({
          r: b.r || Math.random() * radius * 0.9,
          theta: b.theta || Math.random() * Math.PI * 2,
          intensity: b.intensity || 0.5,
          phase: b.phase || 0,
          id: b.id || null,
          entityData: b.entityData || {}
        }));
      },
      
      // Add a single blip
      addBlip: function(blipData) {
        blips.push({
          r: blipData.r || Math.random() * radius * 0.9,
          theta: blipData.theta || Math.random() * Math.PI * 2,
          intensity: blipData.intensity || 0.5,
          phase: blipData.phase || 0,
          id: blipData.id || null,
          entityData: blipData.entityData || {}
        });
      },
      
      // Remove blip by ID
      removeBlip: function(id) {
        const index = blips.findIndex(b => b.id === id);
        if (index !== -1) {
          blips.splice(index, 1);
          if (lockTargetIndex === index) {
            lockTargetIndex = null;
            document.querySelector('[data-action="lock-target"]').classList.remove('active');
          }
        }
      },
      
      // Clear all blips
      clearBlips: function() {
        blips = [];
        lockTargetIndex = null;
        document.querySelector('[data-action="lock-target"]').classList.remove('active');
      },
      
      // Get current blips
      getBlips: function() {
        return blips;
      },
      
      // Lock a specific blip by index or ID
      lockBlip: function(indexOrId) {
        if (typeof indexOrId === 'number') {
          lockTargetIndex = indexOrId;
        } else {
          const index = blips.findIndex(b => b.id === indexOrId);
          if (index !== -1) lockTargetIndex = index;
        }
        if (lockTargetIndex !== null) {
          document.querySelector('[data-action="lock-target"]').classList.add('active');
        }
      },
      
      // Unlock current target
      unlockTarget: function() {
        lockTargetIndex = null;
        document.querySelector('[data-action="lock-target"]').classList.remove('active');
      },
      
      // Get locked target data
      getLockedTarget: function() {
        if (lockTargetIndex === null) return null;
        return blips[lockTargetIndex];
      },
      
      // Set mode programmatically
      setMode: function(mode) {
        const validModes = ['alpha', 'beta', 'gamma'];
        if (validModes.includes(mode)) {
          activeMode = mode;
          clearModeButtons();
          document.querySelector(`[data-action="mode-${mode}"]`).classList.add('active');
        }
      },
      
      // Get current mode
      getMode: function() {
        return activeMode;
      },
      
      // Trigger pulse
      pulse: function() {
        pulsePhase = 1.0;
        const btn = document.querySelector('[data-action="pulse"]');
        btn.classList.add('active');
        setTimeout(() => btn.classList.remove('active'), 180);
      },
      
      // Toggle freeze
      toggleFreeze: function() {
        frozen = !frozen;
        document.querySelector('[data-action="freeze"]').classList.toggle('active', frozen);
      },
      
      // Get freeze state
      isFrozen: function() {
        return frozen;
      },
      
      // Set status text (for HUD updates)
      setStatus: function(text) {
        // Could be extended to update a status display element
        console.log('Status:', text);
      },
      
      // Get canvas radius for coordinate calculations
      getRadius: function() {
        return radius;
      }
    };

    // Log API availability
    console.log('PsychicRadar API ready. Access via window.PsychicRadar');
    console.log('Example: window.PsychicRadar.updateBlips([{r: 100, theta: 1.5, intensity: 0.8}])');
  </script>
</body>
</html>

  <script>
    const ws = new WebSocket('ws://localhost:3000/ws/psychic-radar');
    
    ws.onopen = () => {
      console.log('Connected to Psychic Radar feed');
      document.getElementById('entitiesValue').textContent = 'ONLINE';
    };
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'contacts') {
        const radius = window.PsychicRadar.getRadius();
        const blips = data.contacts.map((contact) => {
          const thetaRadians = (contact.theta * Math.PI) / 180;
          const pixelRadius = contact.r * radius;
          return {
            r: pixelRadius,
            theta: thetaRadians,
            intensity: contact.intensity,
            phase: Math.random() * Math.PI * 2,
            id: contact.id,
            entityData: contact.meta
          };
        });
        window.PsychicRadar.updateBlips(blips);
        document.getElementById('entitiesValue').textContent = data.contacts.length;
      }
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      document.getElementById('entitiesValue').textContent = 'ERROR';
    };
    
    ws.onclose = () => {
      console.log('Disconnected from Psychic Radar');
      document.getElementById('entitiesValue').textContent = 'OFFLINE';
    };
  </script>
