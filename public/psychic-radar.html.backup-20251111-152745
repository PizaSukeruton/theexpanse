<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Psychic Radar PPI (Dossier Terminal v0)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { background:#000000; color:#00FF75; font-family: ui-monospace, "IBM Plex Mono", "Courier New", monospace; margin:0 }
    .container { display:flex; height:100vh }
    .left { width:300px; padding:16px; background:#00130A; border-right:1px solid #00A660; display:flex; flex-direction:column; gap:12px }
    .right { flex:1; display:flex; align-items:center; justify-content:center; background:#000000 }
    .group { display:flex; flex-direction:column; gap:6px }
    label { font-size:12px; color:#00FF75 }
    select, input[type="range"], input[type="text"], button { width:100%; background:#00170D; color:#00FF75; border:1px solid #007A4A; border-radius:10px; padding:8px; font-family:inherit }
    button { cursor:pointer }
    #log { background:#000000; color:#9BFFC3; min-height:120px; max-height:160px; overflow:auto; border-radius:10px; padding:8px; font-size:12px; white-space:pre }
    #bearingHUD { font-size:28px; font-weight:700; color:#00FF75; text-shadow:0 0 18px rgba(0,255,117,0.35) }
    canvas { border-radius:20px; box-shadow:0 0 24px rgba(0,255,117,.25),0 0 64px rgba(0,255,117,.12); background: radial-gradient(circle at 50% 50%, rgba(0,255,117,.05), #000000 70%) }
    .hud { position:relative; width:1024px; display:flex; justify-content:space-between; margin-top:8px; font-size:12px; opacity:.9 }
    .crt::before{ content:""; position:absolute; inset:0; background:repeating-linear-gradient(to bottom,rgba(255,255,255,.02) 0 2px,transparent 2px 4px); mix-blend-mode:overlay; pointer-events:none }
    .crt::after{ content:""; position:absolute; inset:0; background:radial-gradient(ellipse at center,transparent 60%,rgba(0,0,0,.35) 85%,rgba(0,0,0,.75) 100%); pointer-events:none }
  </style>
</head>
<body>
<div class="container">
  <div class="left">
    <div class="group">
      <label>Mode</label>
      <select id="modeSel">
        <option value="live" selected>Live WebSocket</option>
        <option value="sim">Simulator (manual only)</option>
      </select>
      <label>WebSocket URL</label>
      <input id="wsUrl" type="text" value="ws://localhost:3000/ws/psychic-radar" value="ws://localhost:8080/ws/psychic-radar" value="ws://localhost:3000/ws/psychic-radar" value="ws://localhost:3000/ws/psychic-radar" />
      <div style="display:flex; gap:8px">
        <button id="btnConnect">Connect</button>
        <button id="btnDisconnect">Disconnect</button>
      </div>
    </div>

    <div class="group">
      <label>PAD → Polar Mapping</label>
      <select id="padMapSel">
        <option value="A-P">Angle=Arousal, Range=Pleasure</option>
        <option value="atan2A-D">Angle=atan2(A,D), Range=Pleasure</option>
        <option value="atan2P-A">Angle=atan2(P,A), Range=Dominance</option>
      </select>
    </div>

    <div class="group">
      <label>Sweep RPM <span id="rpmOut"></span></label>
      <input id="rpmSlider" type="range" min="3" max="24" value="12" step="0.1" />
      <label>Trail Length (s) <span id="trailOut"></span></label>
      <input id="trailSlider" type="range" min="0.5" max="6" value="3" step="0.1" />
      <label>Gain <span id="gainOut"></span></label>
      <input id="gainSlider" type="range" min="0.5" max="3.0" value="1.0" step="0.05" />
    </div>

    <div class="group">
      <label>Bearing HUD</label>
      <div id="bearingHUD">000°</div>
    </div>

    <div class="group">
      <label>Log</label>
      <div id="log"></div>
    </div>
  </div>

  <div class="right">
    <div class="crt" style="position:relative">
      <canvas id="scope" width="1024" height="1024"></canvas>
      <div class="hud"><div id="hudLeft"></div><div id="hudRight"></div></div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('scope');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const CX = W/2, CY = H/2;
  const R = Math.min(CX, CY) * 0.94;

  const trailCanvas = document.createElement('canvas');
  trailCanvas.width = W; trailCanvas.height = H;
  const tctx = trailCanvas.getContext('2d');

  const modeSel = document.getElementById('modeSel');
  const wsUrl = document.getElementById('wsUrl');
  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const padMapSel = document.getElementById('padMapSel');

  const rpmSlider = document.getElementById('rpmSlider');
  const trailSlider = document.getElementById('trailSlider');
  const gainSlider = document.getElementById('gainSlider');
  const rpmOut = document.getElementById('rpmOut');
  const trailOut = document.getElementById('trailOut');
  const gainOut = document.getElementById('gainOut');
  const bearingHUD = document.getElementById('bearingHUD');
  const logDiv = document.getElementById('log');
  const hudLeft = document.getElementById('hudLeft');
  const hudRight = document.getElementById('hudRight');

  function log(s){ const t = new Date().toISOString().split('T')[1].replace('Z',''); logDiv.textContent += "["+t+"] "+s+"\n"; logDiv.scrollTop = logDiv.scrollHeight; }

  let sweepDeg = 0;
  let rpm = parseFloat(rpmSlider.value);
  let trailSec = parseFloat(trailSlider.value);
  let gain = parseFloat(gainSlider.value);
  let contacts = [];
  let arcs = [];
  let ws = null;
  let sim = null;
  let lastFrame = performance.now();

  const TAU = Math.PI*2, DEG = 180/Math.PI, RAD = Math.PI/180;
  const clamp = (v,a,b)=>Math.min(b,Math.max(a,v));
  const wrap360 = d => (d%360+360)%360;

  function polarToXY(deg, radius){
    const rad = (deg-90)*RAD;
    return [CX + Math.cos(rad)*radius, CY + Math.sin(rad)*radius];
  }

  function padToPolar(pad, scheme){
    const p = clamp(pad?.p ?? 0, -1, 1);
    const a = clamp(pad?.a ?? 0, -1, 1);
    const d = clamp(pad?.d ?? 0, -1, 1);
    let bearing, rangeNorm;
    switch(scheme){
      case 'A-P':
        bearing = wrap360((a * 180) + 180);
        rangeNorm = 1 - ((p + 1)/2);
        break;
      case 'atan2A-D':
        bearing = wrap360(Math.atan2(a, d) * DEG + 180);
        rangeNorm = 1 - ((p + 1)/2);
        break;
      case 'atan2P-A':
        bearing = wrap360(Math.atan2(p, a) * DEG + 180);
        rangeNorm = 1 - ((d + 1)/2);
        break;
      default:
        bearing = wrap360((a * 180) + 180);
        rangeNorm = 1 - ((p + 1)/2);
    }
    return { bearing_deg: bearing, range_px: rangeNorm * R };
  }

  function padToIntensity(pad){
    const p = clamp(pad?.p ?? 0, -1, 1), a = clamp(pad?.a ?? 0, -1, 1), d = clamp(pad?.d ?? 0, -1, 1);
    return Math.sqrt(p*p + a*a + d*d) / Math.sqrt(3);
  }

  function fadeTrails(dt){
    const k = clamp(1 - Math.exp(-dt / trailSec), 0, 1);
    tctx.globalCompositeOperation = 'source-over';
    tctx.fillStyle = "rgba(0,0,0,"+k+")";
    tctx.fillRect(0,0,W,H);
  }

  function drawGrid(){
    ctx.save();
    ctx.strokeStyle = "#00995D";
    ctx.globalAlpha = .6;
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let r=R/5; r<=R; r+=R/5){ ctx.moveTo(CX+r, CY); ctx.arc(CX, CY, r, 0, TAU); }
    ctx.stroke();

    ctx.globalAlpha = .9;
    ctx.strokeStyle = "#00B06A";
    for(let deg=0; deg<360; deg+=10){
      const len = (deg%30===0)? 16 : 8;
      const [x1,y1] = polarToXY(deg, R - len);
      const [x2,y2] = polarToXY(deg, R);
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }

    ctx.fillStyle = "#00FF75";
    ctx.font = "14px IBM Plex Mono, monospace"; ctx.textAlign="center"; ctx.textBaseline="middle";
    [["N",0],["E",90],["S",180],["W",270]].forEach(([t,d])=>{ const [x,y]=polarToXY(d, R-26); ctx.fillText(t,x,y); });
    ctx.restore();
  }

  function drawSweep(){
    const [x,y] = polarToXY(sweepDeg, R);
    tctx.save();
    tctx.strokeStyle = "#9FFFCC";
    tctx.shadowBlur = 24; tctx.shadowColor = "#9FFFCC";
    tctx.globalCompositeOperation = "lighter";
    tctx.beginPath(); tctx.moveTo(CX,CY); tctx.lineTo(x,y); tctx.stroke();
    tctx.restore();
  }

  function drawContactEcho(c){
    let bearing = (typeof c.bearing_deg === "number") ? c.bearing_deg : null;
    let rangePx = null;
    const PAD = c?.meta?.PAD;

    if(bearing==null || c.range_m==null){
      const tmp = padToPolar(PAD, padMapSel.value);
      bearing = bearing==null ? tmp.bearing_deg : bearing;
      rangePx = tmp.range_px;
    }
    if(rangePx==null){
      const Rmax = c?.meta?.Rmax_m ?? 10000;
      rangePx = clamp((c.range_m / Rmax) * R, 0, R);
    }

    const delta = Math.min(wrap360(bearing - sweepDeg), wrap360(sweepDeg - bearing));
    if(delta > 3.0) return;

    const intensity = clamp((typeof c.intensity === "number") ? c.intensity : padToIntensity(PAD), 0, 1);
    const boost = intensity * gain;
    const [x,y] = polarToXY(bearing, rangePx);
    const size = 2 + Math.pow(boost, 0.7) * 5;

    tctx.save();
    tctx.globalCompositeOperation = "lighter";
    tctx.shadowBlur = 18 * (0.6 + boost);
    tctx.shadowColor = "#00FF75";
    tctx.fillStyle = "#00FF75";
    tctx.beginPath(); tctx.arc(x,y,size,0,TAU); tctx.fill();
    tctx.restore();
  }

  function drawArcs(){
    if(!arcs?.length) return;
    tctx.save();
    tctx.globalCompositeOperation = "lighter";
    tctx.strokeStyle = "#00FF75"; tctx.globalAlpha = 0.35; tctx.lineWidth = 1.2;
    for(const a of arcs){
      const [x1,y1] = polarToXY(a.from.bearing_deg, a.from.range_px);
      const [x2,y2] = polarToXY(a.to.bearing_deg, a.to.range_px);
      tctx.beginPath(); tctx.moveTo(x1,y1); tctx.lineTo(x2,y2); tctx.stroke();
    }
    tctx.restore();
  }

  function compose(){
    ctx.clearRect(0,0,W,H);
    drawGrid();
    ctx.drawImage(trailCanvas, 0, 0);
    ctx.save();
    ctx.globalAlpha = .7; ctx.strokeStyle = "#00B06A";
    ctx.beginPath(); ctx.moveTo(CX-8,CY); ctx.lineTo(CX+8,CY); ctx.moveTo(CX,CY-8); ctx.lineTo(CX,CY+8); ctx.stroke();
    ctx.restore();
  }

  function frame(now){
    const dt = Math.min((now - lastFrame)/1000, 0.05); lastFrame = now;
    const revPerSec = rpm / 60;
    sweepDeg = wrap360(sweepDeg + revPerSec*360*dt);

    fadeTrails(dt);
    drawSweep();

    for(const c of contacts){ drawContactEcho(c); }
    drawArcs();

    compose();

    bearingHUD.textContent = Math.round(sweepDeg) + "°";
    hudLeft.textContent = "RPM " + rpm.toFixed(1) + "  Trail " + trailSec.toFixed(1) + "s  Gain " + gain.toFixed(2);
    hudRight.textContent = "Contacts " + contacts.length + "  Sweep " + Math.round(sweepDeg) + "°";
    requestAnimationFrame(frame);
  }

  function handleMessage(obj){
    if(obj?.type === "contacts"){
      contacts = Array.isArray(obj.contacts) ? obj.contacts : [];
      if(typeof obj.sweep_bearing_deg === "number") sweepDeg = wrap360(obj.sweep_bearing_deg);
    } else if(obj?.type === "overlays" && Array.isArray(obj.arcs)){
      arcs = obj.arcs.map(a => {
        const from = a.from?.PAD ? padToPolar(a.from.PAD, padMapSel.value) : { bearing_deg: a.from.bearing_deg, range_px: (a.from.range_m / (a.Rmax_m||10000)) * R };
        const to   = a.to?.PAD   ? padToPolar(a.to.PAD,   padMapSel.value) : { bearing_deg: a.to.bearing_deg,   range_px: (a.to.range_m   / (a.Rmax_m||10000)) * R };
        return { from, to, weight: a.weight ?? 1 };
      });
    }
  }

  function connect(){
    if(ws && ws.readyState===WebSocket.OPEN){ log("WS already open"); return }
    try{
      const url = wsUrl.value && wsUrl.value.trim().length ? wsUrl.value.trim() : null;
      if(!url){ log("Set WebSocket URL then Connect"); return }
      ws = new WebSocket(url);
      ws.onopen = () => log("WebSocket connected");
      ws.onmessage = ev => { try{ handleMessage(JSON.parse(ev.data)) } catch(e){ log("Bad JSON") } };
      ws.onclose = () => log("WebSocket closed");
      ws.onerror = () => log("WebSocket error");
    }catch(e){ log("WS connect failed") }
  }
  function disconnect(){ if(ws){ ws.close(); ws=null } }

  function startSim(){
    stopSim();
    log("Simulator started");
    const ids = Array.from({length: 80}, (_,i)=>(`#${(Math.random()*0xffffff|0).toString(16).padStart(6,'0').toUpperCase()}`));
    sim = setInterval(()=>{
      const now = new Date().toISOString();
      const payload = { type:"contacts", timestamp: now, sweep_bearing_deg: sweepDeg, contacts: [] };
      for(let i=0;i<ids.length;i++){
        const t = performance.now()/1000 + i*0.37;
        const PAD = { p: Math.sin(t*0.21 + i*0.13), a: Math.sin(t*0.31 + i*0.17), d: Math.cos(t*0.27 + i*0.11) };
        const pol = padToPolar(PAD, padMapSel.value);
        const intensity = padToIntensity(PAD) * (0.6 + 0.4*Math.random());
        payload.contacts.push({ id: ids[i], bearing_deg: pol.bearing_deg, range_m: undefined, intensity, class: "Sim", meta:{ PAD } });
      }
      handleMessage(payload);
    }, 50);
  }
  function stopSim(){ if(sim){ clearInterval(sim); sim=null; log("Simulator stopped") } }

  rpmSlider.addEventListener("input", ()=>{ rpm = parseFloat(rpmSlider.value); rpmOut.textContent = rpm.toFixed(1) + " rpm" });
  trailSlider.addEventListener("input", ()=>{ trailSec = parseFloat(trailSlider.value); trailOut.textContent = trailSec.toFixed(1) + " s" });
  gainSlider.addEventListener("input", ()=>{ gain = parseFloat(gainSlider.value); gainOut.textContent = gain.toFixed(2) });
  btnConnect.addEventListener("click", ()=>{ connect(); modeSel.value="live" });
  btnDisconnect.addEventListener("click", ()=>{ disconnect() });
  modeSel.addEventListener("change", ()=>{ if(modeSel.value==="sim") startSim(); else stopSim() });

  rpmOut.textContent = rpm.toFixed(1) + " rpm";
  trailOut.textContent = trailSec.toFixed(1) + " s";
  gainOut.textContent = gain.toFixed(2);
  log("Psychic Radar v0 ready. Mode defaults to Live. Set WebSocket URL and Connect, or switch Mode to Simulator manually.");
  requestAnimationFrame(ts => { lastFrame = ts; frame(ts) });
})();
</script>
</body>
</html>
<!-- labels overlay + responsive sizing (appended) -->
<style>
  .pradar-label-overlay { position:absolute; inset:0; pointer-events:none; }
</style>
<script>
(function(){
  function findRadarCanvas(){
    const canvases = Array.from(document.querySelectorAll('canvas'))
      .filter(c=>c.offsetWidth && c.offsetHeight);
    return canvases.sort((a,b)=>(b.offsetWidth*b.offsetHeight)-(a.offsetWidth*a.offsetHeight))[0] || null;
  }

  function initWhenReady(){
    const radar = findRadarCanvas();
    if(!radar){ requestAnimationFrame(initWhenReady); return; }

    const overlay = document.createElement('canvas');
    overlay.className = 'pradar-label-overlay';
    const wrap = radar.parentElement || document.body;
    if(getComputedStyle(wrap).position === 'static'){ wrap.style.position = 'relative'; }
    wrap.appendChild(overlay);

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const octx = overlay.getContext('2d');

    function sizeOverlay(){
      const r = radar.getBoundingClientRect();
      overlay.style.width  = r.width + 'px';
      overlay.style.height = r.height + 'px';
      overlay.width  = Math.max(1, Math.round(r.width  * dpr));
      overlay.height = Math.max(1, Math.round(r.height * dpr));
      octx.setTransform(dpr,0,0,dpr,0,0);
      octx.font = '12px "Courier New", "IBM Plex Mono", ui-monospace, monospace';
      octx.textBaseline = 'middle';
    }
    sizeOverlay();

    const ro = new ResizeObserver(sizeOverlay);
    ro.observe(radar);
    window.addEventListener('resize', sizeOverlay);

    // capture latest contacts frames without changing existing handlers
    window.__PRADAR_LATEST__ = { sweep_bearing_deg: 0, contacts: [] };
    const _add = WebSocket.prototype.addEventListener;
    WebSocket.prototype.addEventListener = function(type, listener, options){
      if(type === 'message'){
        const wrapped = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            if(msg && msg.type === 'contacts'){
              window.__PRADAR_LATEST__ = msg;
            }
          } catch(e){}
          return listener.call(this, ev);
        };
        return _add.call(this, type, wrapped, options);
      }
      return _add.call(this, type, listener, options);
    };

    function polarToXY(cx, cy, radius, bearingDeg, range01){
      const rad = (bearingDeg * Math.PI) / 180;
      const r = radius * Math.max(0, Math.min(1, range01));
      const x = cx + r * Math.cos(rad);
      const y = cy - r * Math.sin(rad);
      return { x, y };
    }

    function padToPolar(pad){
      const a = typeof pad?.a === 'number' ? pad.a : 0;
      const p = typeof pad?.p === 'number' ? pad.p : 0;
      const angle = ((a + 1) / 2) * 360;
      const range01 = 1 - ((p + 1) / 2);
      return { angle, range01 };
    }

    function drawLabels(){
      const r = overlay.getBoundingClientRect();
      const w = r.width, h = r.height;
      octx.clearRect(0,0,w,h);

      // your radar is drawn as a quarter-circle from bottom-right corner
      const cx = w;
      const cy = h;
      const radius = Math.min(w, h);

      const latest = window.__PRADAR_LATEST__;
      const contacts = Array.isArray(latest.contacts) ? latest.contacts : [];

      for(const c of contacts){
        const name = (c.meta && c.meta.character_name) || c.id || '';
        if(!name) continue;

        let bearingDeg, range01;
        if(typeof c.bearing_deg === 'number' && typeof c.range_m === 'number'){
          const Rmax = (c.meta && typeof c.meta.Rmax_m === 'number' && c.meta.Rmax_m > 0) ? c.meta.Rmax_m : 10000;
          bearingDeg = c.bearing_deg;
          range01 = Math.max(0, Math.min(1, c.range_m / Rmax));
        } else if (c.meta && c.meta.PAD) {
          const pr = padToPolar(c.meta.PAD);
          bearingDeg = pr.angle;
          range01 = pr.range01;
        } else {
          continue;
        }

        const { x, y } = polarToXY(cx, cy, radius, bearingDeg, range01);

        // small glow dot
        octx.beginPath();
        octx.arc(x, y, 2.5, 0, Math.PI*2);
        octx.fillStyle = 'rgba(0,255,117,0.9)';
        octx.fill();

        // text label with subtle contrast box
        const label = name;
        const pad = 4;
        const textW = octx.measureText(label).width;
        const boxW = textW + pad*2;
        const boxH = 16;

        // offset label slightly along the sweep direction
        const offX = 8;
        const offY = -10;

        const bx = Math.min(w - boxW, Math.max(0, x + offX));
        const by = Math.min(h - boxH, Math.max(0, y + offY));

        octx.fillStyle = 'rgba(0,0,0,0.45)';
        octx.fillRect(bx, by, boxW, boxH);
        octx.strokeStyle = 'rgba(0,255,117,0.25)';
        octx.strokeRect(bx+0.5, by+0.5, boxW-1, boxH-1);

        octx.fillStyle = 'rgba(0,255,117,0.95)';
        octx.fillText(label, bx + pad, by + boxH/2);
      }

      requestAnimationFrame(drawLabels);
    }

    requestAnimationFrame(drawLabels);
  }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initWhenReady);
  } else {
    initWhenReady();
  }
})();
</script>
